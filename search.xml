<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>yolo系列基础学习</title>
      <link href="/2023/07/04/yoloV3/"/>
      <url>/2023/07/04/yoloV3/</url>
      
        <content type="html"><![CDATA[<h1 id="yolov1">Yolov1</h1><h2 id="核心内容">核心内容</h2><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230704171038267.png"alt="分而治之" /><figcaption aria-hidden="true">分而治之</figcaption></figure><p>①分而治之，其类似卷积神经网络，目的是通过分块找到物体中心，其核心思路就是一个莽，全都用CNN莽出来</p><p>②leaky ReLu <span class="math display">\[y=\begin{array}{l}  \left\{\begin{matrix}  x,x&gt;0 \\0.1x,otherwise\end{matrix}\right.    \end{array}\]</span> ③ 端到端训练</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/20180910130225149"alt="端到端训练" /><figcaption aria-hidden="true">端到端训练</figcaption></figure><h1 id="yolov2">Yolov2</h1><h2 id="同比v1的改进">同比v1的改进</h2><p><strong>tradeoff：折中</strong></p><p>batch normalization：某种正则化手段，BN</p><p>high resolution classifier：微调与训练模型</p><p>Convolutional With Anchor Boxes：anchor机制</p><ul><li><p>Dimension Clusters：选择anchorprior需要手动设置，采用k-means聚类找到一个合适的大小</p></li><li><p>Direct location prediction: 解决不稳定，相对位置预测</p></li></ul><p>Fine-Grained Features: 调整后的yolo将在13*13的特征上做检测任务</p><p>multi-scale training：多标准化输入训练</p><p>Darknet-19：backbone网络</p><h1 id="yolov3">Yolov3</h1><h2 id="基本流程">基本流程</h2><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/24215864-83d220ef29016abf"alt="基本组件" /><figcaption aria-hidden="true">基本组件</figcaption></figure><h2 id="保留部分">保留部分</h2><ul><li>分割检测</li><li>leaky ReLu</li><li>端到端训练，loss function 不变</li><li>BN正则化不变，放在leaky ReLu和每一层卷积后</li><li>mult scale training</li></ul><h2 id="基本组件">基本组件</h2><p>CBL：Yolov3网络结构的最小组件，由Conv+Bn+Leaky_relu组成</p><p>Res unit：借鉴Resnet网络中的残差结构，让网络可以构建的更深。</p><p>ResX：由一个CBL和X个残差组件构成</p><h2 id="基础操作">基础操作</h2><p>Concat：拼接</p><p>Add：张量相加，与shortcut功能一致</p><h2 id="backbone">backbone</h2><p>v3中没有池化层和全连接层，尺寸变换通过改变卷积和步长</p><p>backbone会将输入图片的尺寸缩短到原来的<spanclass="math inline">\(\frac{1}{32}\)</span>,所以要求输入图片得是32的倍数</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/24215864-e67c9e615638e745"alt="尺寸变换比较" /><figcaption aria-hidden="true">尺寸变换比较</figcaption></figure><p>这里要注意Darknet-19是要比Darknet-53快的，因此v3还提供了tinynet</p><h2 id="perdictions-across-scales">Perdictions across scales</h2><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230705105112921.png"alt="image-20230705105112921" /><figcaption aria-hidden="true">image-20230705105112921</figcaption></figure><p>这个借鉴了FPN(feature pyramidnetworks)，采用多尺度来对不同size的目标进行检测，越精细的gridcell就可以检测出越精细的物体。规律为1:2:4</p>]]></content>
      
      
      
        <tags>
            
            <tag> 视觉 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python高维数据分析实验报告</title>
      <link href="/2023/04/23/pythonHighDeminsion/"/>
      <url>/2023/04/23/pythonHighDeminsion/</url>
      
        <content type="html"><![CDATA[<h1 id="实验一-python基础语法学习总结">实验一Python基础语法学习总结</h1><h2 id="实验目的">实验目的</h2><p>学习Python基本语法</p><h2 id="实验场地与设备">实验场地与设备</h2><p>线上</p><h2 id="实验方式">实验方式</h2><p>阅读教程与程序设计</p><h2 id="实验设计">实验设计</h2><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.png"alt="Python语言基础" /><figcaption aria-hidden="true">Python语言基础</figcaption></figure><p><span class="math display">\[图1.1 Python基础语法学习实验设计\]</span></p><h2 id="实验内容">实验内容</h2><h3 id="python语法总结">1. Python语法总结</h3><h4 id="python基本语法">1.1 Python基本语法</h4><h4 id="基本语句">（1） 基本语句</h4><p>①首先是输入输出语句，输入语句比较简单为<code>name=input()</code>，基本输出语句为<code>print()</code>,拼接输出使用逗号。</p><p>② 注释采用<code>#</code> 进行书写</p><p>③代码风格：Python采用的是缩进式代码风格，所以对于复制粘贴比较不友好</p><p>④条件判断语句：<code>if 条件1 :...elif 条件2 : ... else : ...</code></p><p>⑤ 循环语句：</p><p>第一种是<code>for</code>循环：<code>for x in []:</code><code>for x in ...:</code>循环就是把每个元素代入变量x，然后执行缩进块的语句</p><p>第二种是<code>while</code>循环：<code>while 条件判断语句 :</code><code>break</code>、<code>continue</code>和java中用法相同</p><h4 id="数据类型">（2） 数据类型</h4><p><strong>①整数：</strong>对于很大的数，很难数清楚0的个数。Python允许在数字中间以_分隔。</p><p><strong>② 浮点数：</strong>允许使用科学计数法定义</p><p><strong>③字符串：</strong>在Python没有严格要求<code>''</code>和<code>""</code>的区别在，也就是说没有区分字符和字符串使用二者没有任何区别。</p><ul><li>转义符和Java中保持一致</li><li>Python允许用<code>r''</code>表示<code>''</code>内部的字符串默认不转义</li></ul><p><strong>④ 布尔值：</strong></p><p>在Python中要注意：<code>True</code>、<code>False</code>要注意开头首字母大写。可以进行与、或、非的运算，运算符分别为：<code>and</code>，<code>or</code>，<code>not</code></p><p><strong>⑤空值：</strong>空值用<code>None</code>表示，意义与Java中的<code>null</code>相同。</p><p><strong>⑥ list：</strong></p><p>list是Python内置的一种数据类型，list是一种有序的集合，可以随时添加和删除其中的元素。此数据类型在Java的实用类中有封装。list和数组很像，声明方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classname = [<span class="string">&#x27;老六&#x27;</span>,<span class="string">&#x27;老八&#x27;</span>,<span class="string">&#x27;老九&#x27;</span>]</span><br></pre></td></tr></table></figure><p>想要调取其中的某个元素也和数组一致，赋值修改等也相同<br />下面列举一下list的ADT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list:</span><br><span class="line">append(&#x27;Elem&#x27;)  # 在末尾添加新的元素</span><br><span class="line">insert(i,&#x27;Elem&#x27;) # 将元素插入指定位置</span><br><span class="line">pop() # 删除末尾元素</span><br><span class="line">pop(i) # 删除i处的元素</span><br><span class="line">len(list) # list列表的长度</span><br></pre></td></tr></table></figure><p>list允许混合类型，也允许list嵌套，从而出现多维数组。</p><p><strong>⑦ tuple</strong></p><p>tuple被称为元组，其最大的特点就是不可修改，声明方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classname = (<span class="string">&#x27;老六&#x27;</span>,<span class="string">&#x27;老八&#x27;</span>,<span class="string">&#x27;老九&#x27;</span>)</span><br></pre></td></tr></table></figure><p>tuple在定义时要确定元素个数，这里有一个问题，在定义只有一个元素的tuple时，Python语法会认为这是一个小括号，因此在定义一个元组的tuple时，要加一个<code>,</code>避免歧义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><p><strong>⑧ 字典（dict）</strong></p><p>字典全称为dictionary，在Java实用类中叫hashmap。其由键值对（key-value）组成，查找速度快。下面是一种初始化方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure><p>也可以放入指定的key中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="string">&#x27;Adam&#x27;</span>] = <span class="number">67</span></span><br></pre></td></tr></table></figure><p>查找value:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure><p>key与value是多对一的关系，key需要是一个不可变对象保证key做hash运算后的唯一性。如果多次对某个key赋值，后边的value会覆盖前面的value提供了几个函数：</p><ol type="1"><li>通过<code>in</code>来判断key是否在dict中，返回值为布尔值，格式为：<code>key in dict</code></li><li>get()方法，<code>dict.get('key',空返回值)</code>key不存在时返回空返回值，空返回值可自定义，如果没有定义的话返回None</li><li>pop()方法，删除key，如果有value也一并删除，格式为<code>pop('key')</code></li></ol><p><strong>⑨ 集合（set）</strong></p><p>set是一组key的集合,集合特点；无序性、确定性、互异性要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><ul><li>方法： <code>add(key)</code>添加一个新的元素<code>remove(key)</code>删除一个元素</li><li>两个set可以做交运算和并运算： 交运算：<code>s1&amp;s2</code>并运算：<code>s1|s2</code></li></ul><h4 id="理解变量">（3） 理解变量</h4><p>在Python中变量仅仅是一个一个字母，变量与所对应的值之间的关系靠指针联系起来的。所以很重要的一点就是：<strong>当我们使用变量时，更多的要关注变量指向的东西，他可能是值，也可能是一个函数，也可能是一个变量</strong></p><h4 id="模块">1.2 模块</h4><h4 id="模块导入">（1） 模块导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="模块下载">（2） 模块下载</h4><p>模块下载有比较复杂的方法，也有比较傻瓜式的。先说复杂的，使用Python中自带的pip包管理工具，用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>但是使用pip需要事先了解要导的包的名字，而且不能批量导入，而且在Python编程里也有编程一分钟，导包一小时的说法。pip下载第三方库的源可能会很慢或者失效，需要会自己添加国内的高速镜像。</p><p>傻瓜式的导包，例如在pycharm中可以直接在代码中写出自己需要的包，然后交给pycharm自己去下载，或者用Anaconda提前构建好的Python的库环境。</p><h4 id="函数式编程">1.3 函数式编程</h4><h4 id="函数">（1） 函数</h4><p><strong>① 函数定义</strong></p><p>在Python中定义函数为，<code>def 函数名(参数):</code>然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。<br />如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。returnNone可以简写为return。</p><p>1）空函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这里<code>pass</code>作为占位符，表示跳过，也可以用在<code>if</code>的缩进块。</p><p>2）参数限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">      <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br></pre></td></tr></table></figure><p>实际上参数限制就是定义一个报错，<code>isinstance()</code>判断数据类型，如果不是就提出一个错误。<strong>作为一个弱类型语言，定义这一步是很有必要的，有助于读懂代码。</strong></p><p>3）返回值：</p><p>Python允许返回多个值，其返回的实际上是一个tuple元组，但是也可以用两个变量接收。</p><p><strong>② 参数定义</strong></p><p>在Python中函数参数的定义也比较灵活，提供位置参数、默认参数、可变参数、关键字（key）参数等</p><p>1）位置参数：位置参数指的是参数在传入时，实参和形参有着严格的位置对应关系，为常用参数形式。</p><p>2）默认参数：默认参数是指在位置参数的基础上为其添加默认值，有默认值的参数为默认参数，没有默认值的参数为必选参数基本定义形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_def</span>(<span class="params">a,b=<span class="number">1</span></span>):</span><br><span class="line">    a=b+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>默认参数必须在必选参数后边，否则会无法辨认是否输入必选参数，从而报错。</li><li>默认参数的默认值一定是<strong>不变对象</strong>，由于Python中的变量定义为指针指向，会导致可变对象值发生变化</li></ul><p>3）不可变对象有：数值类型、字符串、tuple元组、None等</p><p>4）可变参数：可变参数指的是参数的数目不固定，定义形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">*v</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> vi <span class="keyword">in</span> v:</span><br><span class="line">        <span class="built_in">sum</span>+=vi</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>在可变参数中传入的所有参数将作为一个tuple被接收，该tuple的变量名为函数在定义时的形参名，定义时的需要在参数名前加一个<code>*</code>。</p><p>5）关键字（key）参数</p><p>此处的关键字和c语言中的关键字并不是一个意义，而是在dict中的key的意义。即在传递参数时，同时传递键（key）和值(value),Python会自动封装为一个dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">**v</span>):</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>6）命名关键字参数</p><p>在关键字参数上，进一步限制传入的key的命名，就有了命名关键词参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br></pre></td></tr></table></figure><p>这里需要一个<code>*</code>区分位置参数与命名关键字参数，如果在这之前有可变参数，那么就不需要加<code>*</code>。<br />命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><p>7）参数组合</p><p>在一个函数中使用多个参数要保证其中的顺序，依次为：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onefunction</span>(<span class="params">a,b,c=<span class="number">0</span>,*args,job,city,**kw</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>tips：</p><ul><li>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法。</li><li>可变参数和关键字参数有一点层级的感觉，中间包裹的是命名关键字参数这个比较尴尬的参数。</li></ul><p><strong>③ 递归函数</strong></p><p>写法与Java相同。</p><h4 id="实用方法">（2） 实用方法</h4><p><strong>① 切片</strong></p><p>切片是一个针对tuple和list方便地取元素的方法，语法规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L[起始坐标:终止坐标:步长]</span><br></pre></td></tr></table></figure><p>当起始坐标为0时可以省略；步长为1时可以省略。</p><p><strong>② 迭代</strong></p><p>迭代是循环的增强，但是想要弄清迭代，需要知道两件事：一个是能不能迭代，一个是迭代出的数据是什么</p><p>想要知道一个数据能否迭代可以通过一个函数来完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">isinstance</span>(L,Iterable)</span><br></pre></td></tr></table></figure><p>迭代出的是什么，和要迭代的对象的储存方式，要特殊记忆一下dic。</p><p><strong>③ 列表生成器</strong></p><p>一种快捷生成list的方式，一个例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><p>如果想要筛选生成的值，可以在<code>for</code>后加上<code>if</code>作为<strong>筛选条件</strong>，注意这里是筛选条件，因此这里和平时的<code>if else</code>并不是一个东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>④ 生成器</strong></p><p>生成器是一种惰性的计算方式。包含<code>yield</code>关键字，当一个函数包含<code>yield</code>关键字时，他就成了一个generator函数。<code>yield</code>在generator函数中起到了一个return的作用，即到<code>yield</code>便返回。在调用时，使用一个变量接受一个generator对象。使用<code>next()</code>函数依次获得下一个返回值。</p><p><strong>⑤ 迭代器</strong></p><p>区分<code>Iterable</code>和<code>Iterator</code></p><p><code>Iterable</code>是可迭代的，是直接可用于<code>for</code>循环的。包括dict、list、tuple、set、str、grenerator。<code>Iterator</code>是迭代器，是直接可用于<code>next()</code>函数的，生成器都是<code>Iterator</code>对象，集合数据类型可以通过<code>iter()</code>获取<code>Interator</code>对象。</p><h4 id="函数式编程-1">（3） 函数式编程</h4><p>函数式编程是一种面向过程的编程思想，实际上是将复杂问题转化为一个个函数。</p><p>在Java的函数定义中，除去<code>void</code>类型不返回值，其余的都需要返回值。因此也就经常存在，使用一个变量接受函数值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(x,y)</span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a=function(x,y);</span><br></pre></td></tr></table></figure><p>那么是不是存在一种可能，我们可以将函数嵌套，让函数调用函数，让函数返回函数，彻底抛弃变量？</p><p>抛弃变量、只有函数就是彻底的函数式编程</p><p><strong>① 理解高阶函数</strong></p><p>之前有过变量名和值的理解，在Python中变量名和值是一个指针指向的关系。同理，函数名和函数也是这样的，函数名也是一个变量。也就是说，我们可以通过函数名，拿到函数体。也就是说函数名是什么并不重要，我们看中的是函数体。</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/%E7%BB%98%E5%9B%BE1.png"alt="绘图1" /><figcaption aria-hidden="true">绘图1</figcaption></figure><p>那么设想一种情况，现在我们定义了函数f2，那么我可以随便写一个函数，然后返回一个变量f2，那么实际上我就拿到了函数体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"><span class="built_in">print</span>(f3()(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220909173741530.png"alt="image-20220909173741530" /><figcaption aria-hidden="true">image-20220909173741530</figcaption></figure><p>然后我们在设想另一种情况，现在我们定义了另一种情况，我们在一个函数中写了一个f1作为局部变量，那么我就可以传入变量f2，然后就相当于传入了函数体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a,b,f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(a,b)</span><br><span class="line"><span class="built_in">print</span>(f1(<span class="number">1</span>,<span class="number">2</span>,f2))</span><br></pre></td></tr></table></figure><p>现在就可以进行一个区分：</p><ul><li><code>f</code>代表函数名，是变量</li><li><code>f()</code>代表数值，是函数的返回值，返回值是一个量</li></ul><p>高阶函数，就是让函数的参数能够接收别的函数。</p><p>实用的几个函数，有必要查表即可</p><p><strong>② 返回函数</strong></p><p>同上文理解，只不过是将一个函数嵌套入了另一个函数</p><p><strong>③ lambda表达式</strong></p><p>与Java中语法相同，目的是为了简化返回函数嵌套</p><h4 id="面向对象编程">1.4 面向对象编程</h4><h4 id="类和对象">（1）类和对象</h4><p>创建类：语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">继承的类</span>):</span><br></pre></td></tr></table></figure><p>python的类非常随意，几乎可以不定义就能用。在类中自带有一个构造函数<code>__init__()</code>,此函数可以重新定义</p><p>生成对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=A()</span><br></pre></td></tr></table></figure><h4 id="访问权限">（2）访问权限</h4><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p><p>此外，<code>__ __</code>这种变量都是特殊变量，在不清楚的时候不要随便乱改</p><h4 id="继承和多态">（3）继承和多态</h4><p>和Java中的思想完全相同</p><h4 id="常用变量和方法">（4）常用变量和方法</h4><p>① <code>__slots__</code></p><p>用这个变量可以起到参数列表的功能，可以在一定程度上限制参数的变量名，用turple进行限定</p><p>② <code>@property</code></p><p>注解编程，可以起到一个简化定义setter和getter函数的作用。<spanclass="citation"data-cites="property注解在getter方法上">@property注解在getter方法上</span>，然后会自动生成<span class="citation" data-cites="函数名.setter">@函数名.setter</span>的注解，但是要注意的一点是，在getter中就不能使用函数名作为自身的调用值，否则会出现无限的调用，产生爆栈。</p><p>③ 多继承</p><p>与Java相同</p><p>⑤ <code>__str__</code>:和Java中的toString方法相同</p><h4 id="错误调试">1.5 错误调试</h4><h4 id="错误处理">（1）错误处理</h4><p>参照Java中，对比来学习即可：</p><p>两种方法，一是尝试，二是抛出，尝试采用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> baseexception  :</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>抛出采用<code>raise</code>关键字</p><h4 id="测试">（2）测试</h4><p>①断言：<code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code></p><p>② 断点：在强大IDE的辅助下，使用断点调试应该是最简单的。</p><h3 id="实践">2.实践</h3><h4 id="石头剪子布">2.1 石头剪子布</h4><p>使用random包中的random函数和条件控制语句，模拟两个电脑互相猜拳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">win</span>(<span class="params">pc,cc</span>):</span><br><span class="line">    <span class="keyword">if</span> (cc==<span class="number">1</span> <span class="keyword">and</span> pc==<span class="number">2</span>) <span class="keyword">or</span> (cc==<span class="number">2</span> <span class="keyword">and</span> pc==<span class="number">3</span>)<span class="keyword">or</span>(cc==<span class="number">3</span> <span class="keyword">and</span> pc==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;电脑一输&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> pc==cc:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;平&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;电脑二输&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computer_choice</span>():</span><br><span class="line">    cc=random.randint(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">pc,cc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑一的出招为&quot;</span>,pc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑二的出招为&quot;</span>,cc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        pc=computer_choice()</span><br><span class="line">        cc=computer_choice()</span><br><span class="line">        show(pc,cc)</span><br><span class="line">        win(pc,cc)</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914212607801.png"alt="image-20220914212607801" /><figcaption aria-hidden="true">image-20220914212607801</figcaption></figure><p>改进提升一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">win</span>(<span class="params">pc,cc</span>):</span><br><span class="line">    <span class="keyword">if</span> (cc==<span class="number">1</span> <span class="keyword">and</span> pc==<span class="number">2</span>) <span class="keyword">or</span> (cc==<span class="number">2</span> <span class="keyword">and</span> pc==<span class="number">3</span>)<span class="keyword">or</span>(cc==<span class="number">3</span> <span class="keyword">and</span> pc==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;玩家输&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> pc==cc:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;平&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;玩家赢&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computer_choice</span>():</span><br><span class="line">    cc=random.randint(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str</span>(<span class="params">cc</span>):</span><br><span class="line">    <span class="keyword">if</span> cc==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;石头&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> cc==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;剪刀&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;布&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">f,pc,cc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑一的出招为&quot;</span>,f(pc))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑二的出招为&quot;</span>,f(cc))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        cc=computer_choice()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入：1.石头 2.剪刀 3.布&quot;</span>)</span><br><span class="line">        pc=<span class="built_in">input</span>()</span><br><span class="line">        show(<span class="built_in">str</span>,pc,cc)</span><br><span class="line">        win(pc,cc)</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914213324805.png"alt="image-20220914213324805" /><figcaption aria-hidden="true">image-20220914213324805</figcaption></figure><h4 id="atm模拟">2.2 ATM模拟</h4><p>通过类和对象简单的设计了一个ATM取钱模拟器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Account</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ATM</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,money,accounts</span>):</span><br><span class="line">        self.money=money</span><br><span class="line">        self.accounts=accounts</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._money;</span><br><span class="line"><span class="meta">    @money.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self,value</span>):</span><br><span class="line">        self._money=value</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accounts</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._accounts</span><br><span class="line"><span class="meta">    @accounts.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accounts</span>(<span class="params">self,value</span>):</span><br><span class="line">        self._accounts=value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchId</span>(<span class="params">self,<span class="built_in">id</span></span>):</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">            <span class="keyword">if</span> account.<span class="built_in">id</span>==<span class="built_in">id</span>:</span><br><span class="line">                <span class="keyword">return</span> account</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入账号id&#x27;</span>)</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">input</span>()</span><br><span class="line">        account1 = self.searchId(<span class="built_in">id</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入密码&#x27;</span>)</span><br><span class="line">        password = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> password == account1.password:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;欢迎&quot;</span>, account1.name)</span><br><span class="line">        <span class="keyword">return</span> account1</span><br><span class="line">    <span class="comment"># 存钱</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_money</span>(<span class="params">self</span>):</span><br><span class="line">        account=self.lode();</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入要存入的数目&quot;</span>)</span><br><span class="line">        saveMneyValue=<span class="built_in">input</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;存款成功&#x27;</span>)</span><br><span class="line">        account.remain=<span class="built_in">int</span>(account.remain)+<span class="built_in">int</span>(saveMneyValue)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;您的账户余额为&#x27;</span>,account.remain)</span><br><span class="line">        self.money=self.money+<span class="built_in">int</span>(saveMneyValue)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取钱</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw_money</span>(<span class="params">self</span>):</span><br><span class="line">        account=self.lode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入要取出的数目&#x27;</span>)</span><br><span class="line">        withdrawMoneyValue=<span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> account.remain &gt; withdrawMoneyValue:</span><br><span class="line">            account.remain=<span class="built_in">int</span>(account.remain)-<span class="built_in">int</span>(withdrawMoneyValue)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;取款成功，您的账户余额为&#x27;</span>,account.remain)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;您的账户余额不足&#x27;</span>)</span><br><span class="line">        self.money=<span class="built_in">int</span>(self.money)-<span class="built_in">int</span>(withdrawMoneyValue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前ATM中有金额&quot;</span>,self.money,<span class="string">&quot;元&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># atm1=ATM(1000)</span></span><br><span class="line">    <span class="comment"># atm1.__str__()</span></span><br><span class="line">    <span class="comment"># atm1.ave_money(200)</span></span><br><span class="line">    <span class="comment"># atm1.__str__()</span></span><br><span class="line">    <span class="comment"># atm1.withdraw_money(200)</span></span><br><span class="line">    <span class="comment"># atm1.__str__()</span></span><br><span class="line">    accounts=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        name=<span class="built_in">input</span>()</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">input</span>()</span><br><span class="line">        password=<span class="built_in">input</span>()</span><br><span class="line">        remain=<span class="built_in">input</span>()</span><br><span class="line">        accounts.append(Account.account(name, <span class="built_in">id</span>, password, remain))</span><br><span class="line">    atm2=ATM(<span class="number">10000</span>,accounts)</span><br><span class="line">    atm2.save_money()</span><br><span class="line">    atm2.withdraw_money()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">account</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,<span class="built_in">id</span>,password,remain</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.remain=remain</span><br><span class="line">        self.password=password</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;remain&#x27;</span>,<span class="string">&#x27;password&#x27;</span>,<span class="string">&#x27;id&#x27;</span>)</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914214759256.png"alt="image-20220914214759256" /><figcaption aria-hidden="true">image-20220914214759256</figcaption></figure><h4 id="圣诞树画图">2.3 圣诞树画图</h4><p>使用Python自带的turtle包，进行圣诞树绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line">screen = turtle.Screen()</span><br><span class="line">screen.setup(<span class="number">375</span>, <span class="number">700</span>)</span><br><span class="line"></span><br><span class="line">circle = turtle.Turtle()</span><br><span class="line">circle.shape(<span class="string">&#x27;circle&#x27;</span>)</span><br><span class="line">circle.color(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">circle.speed(<span class="string">&#x27;fastest&#x27;</span>)</span><br><span class="line">circle.up()</span><br><span class="line"></span><br><span class="line">square = turtle.Turtle()</span><br><span class="line">square.shape(<span class="string">&#x27;square&#x27;</span>)</span><br><span class="line">square.color(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">square.speed(<span class="string">&#x27;fastest&#x27;</span>)</span><br><span class="line">square.up()</span><br><span class="line"></span><br><span class="line">circle.goto(<span class="number">0</span>, <span class="number">280</span>)</span><br><span class="line">circle.stamp()</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">13</span>):</span><br><span class="line">    y = <span class="number">30</span> * i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - k):</span><br><span class="line">        x = <span class="number">30</span> * j</span><br><span class="line">        square.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line">        square.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        x = <span class="number">30</span> * (j + <span class="number">1</span>)</span><br><span class="line">        circle.color(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        circle.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line">        circle.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line">        k += <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        x = <span class="number">30</span> * (j + <span class="number">1</span>)</span><br><span class="line">        circle.color(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">        circle.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line">        circle.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line"></span><br><span class="line">square.color(<span class="string">&#x27;brown&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>, <span class="number">17</span>):</span><br><span class="line">    y = <span class="number">30</span> * i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        x = <span class="number">30</span> * j</span><br><span class="line">        square.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line">        square.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line">turtle.mainloop()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914215352995.png"alt="image-20220914215352995" /><figcaption aria-hidden="true">image-20220914215352995</figcaption></figure><h2 id="总结">3.总结</h2><p>Python作为一个弱类型语言，是有他的弊端的，在一些需要数据类型转换和严格控制数据类型的情况下，会非常难受。而Python最大的优势在于有大量的库，这些库在特定的编程领域会非常便利。Python本身的语言具有极强的灵活性，而灵活性的言外之意就是规范性很难确定。因此，Python的重点是将第三方包为我所用，在数值计算中发挥他最大的作用。</p><h1 id="实验二-python科学计算库和高维数据导入方法">实验二PYTHON科学计算库和高维数据导入方法</h1><h2 id="实验目的-1">实验目的</h2><ol type="1"><li>掌握基本的numpy对象及其对应方法</li><li>掌握常用的numpy数学函数，学习查找numpy帮助文档</li><li>重点学习numpy线性代数方法</li><li>掌握matplotlib的绘图对象关系</li><li>掌握基本的绘制图形的方法，包括绘制、属性设置、子图</li><li>能够通过查阅文档、示例，画出复杂图像</li><li>导入mat数据集</li></ol><h2 id="实验场地与设备-1">实验场地与设备</h2><p>实验室4074</p><h2 id="实验方式-1">实验方式</h2><p>阅读教程与程序设计</p><h2 id="实验设计-1">实验设计</h2><p>使用corn数据集进行学习</p><h2 id="实验内容-1">实验内容</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">data=sio.loadmat(<span class="string">&quot;NIRcorn.mat&quot;</span>)</span><br><span class="line"><span class="comment"># 首先输出data观察一下data的组成</span></span><br><span class="line"><span class="comment"># print(data)</span></span><br><span class="line"><span class="comment"># 观察到下面的数据实际上是一个dict,那么就可以通过k-v进行取值。</span></span><br><span class="line"><span class="comment"># print(data.keys())</span></span><br><span class="line"><span class="comment"># 输出结果如下</span></span><br><span class="line"><span class="comment"># &#x27;__header__&#x27;, &#x27;__version__&#x27;, &#x27;__globals__&#x27;, &#x27;m5spec&#x27;, &#x27;cornspect&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;cornwavelength&#x27;, &#x27;propvals&#x27;, &#x27;cornprop&#x27;, &#x27;NIRcoin&#x27;, &#x27;information&#x27;,</span></span><br><span class="line"><span class="comment"># &#x27;mp5spec&#x27;, &#x27;mp6spec&#x27;, &#x27;m5nbs&#x27;, &#x27;mp5nbs&#x27;, &#x27;mp6nbs&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">首先debug，观察变量信息，发现header、version、global都没有什么实际用处，应该是数据集作者做的标注</span></span><br><span class="line"><span class="string">通过查找原数据集页面，得知：</span></span><br><span class="line"><span class="string">information:Information about the data,数据说明</span></span><br><span class="line"><span class="string">以下都是根据NBS的玻璃标准划分的仪器信息</span></span><br><span class="line"><span class="string">    m5nbs:NBS glass stds on m5 </span></span><br><span class="line"><span class="string">    mp5nbs:NBS glass stds on mp5 </span></span><br><span class="line"><span class="string">    mp6nbs:NBS glass stds on mp6</span></span><br><span class="line"><span class="string">这些和玉米都没有关系</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">查阅翻译：</span></span><br><span class="line"><span class="string">cornspect：吸光率数值</span></span><br><span class="line"><span class="string">cornwavelength：玉米波长</span></span><br><span class="line"><span class="string">cornprop：玉米的一些属性</span></span><br><span class="line"><span class="string">propvals:Property values for samples，这个里边有 &#x27;Moisture&#x27;,&#x27;Oil&#x27;,&#x27;Protein &#x27;,&#x27;Starch&#x27;  </span></span><br><span class="line"><span class="string">下面这些是从三台不同的仪器上获得的光谱：</span></span><br><span class="line"><span class="string">    m5spec:Spectra on instrument m5 </span></span><br><span class="line"><span class="string">    mp5spec:Spectra on instrument mp5</span></span><br><span class="line"><span class="string">    mp6spec:Spectra on instrument mp6 </span></span><br><span class="line"><span class="string">观察provals和cornprop的值，我们可以发现，这二者数据一模一样，所以只需要使用conprop即可。</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">a=data[&#x27;m5spec&#x27;]</span></span><br><span class="line"><span class="string">print(type(a))</span></span><br><span class="line"><span class="string">print(a)</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># print(a)</span></span><br><span class="line"><span class="comment"># 经过测试是可行的，但是里边还有一些其他的组成</span></span><br><span class="line"><span class="comment"># debug观察，发现a中只有一个元素就是我们所输出的</span></span><br><span class="line"><span class="comment"># 并且该数据的数据类型为&lt;class &#x27;numpy.ndarray&#x27;&gt;</span></span><br><span class="line"><span class="comment"># 又观察到内部实际上存在几个“表头”，所以他实际上是一个结构数组，</span></span><br><span class="line"><span class="comment"># 转到MATLAB观察原数据，发现确实是一个结构体，在读取时自动转化为了结构数组</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># m5spec=data[&#x27;m5spec&#x27;]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 下面开始正式分析画图：</span></span><br><span class="line">cornwavelength=data[<span class="string">&quot;cornwavelength&quot;</span>]</span><br><span class="line">x=[]</span><br><span class="line"><span class="comment"># 输出观察发现，是一个ndarray组成的list所以只取第一个元素</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(cornwavelength)):</span><br><span class="line">    x.append(cornwavelength[i][<span class="number">0</span>])</span><br><span class="line"><span class="comment"># 获取吸光率</span></span><br><span class="line">cornspect = data[<span class="string">&#x27;cornspect&#x27;</span>]</span><br><span class="line"><span class="comment"># 随机取出五组透光率</span></span><br><span class="line"><span class="comment"># 先随机生成五组数据</span></span><br><span class="line">rd=np.random.randint(<span class="number">0</span>,<span class="number">80</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 存储透光率数据</span></span><br><span class="line">y1 = []</span><br><span class="line">y2 = []</span><br><span class="line">y3 = []</span><br><span class="line">y4 = []</span><br><span class="line">y5 = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="number">700</span>):</span><br><span class="line">    y1.append(cornspect[rd[<span class="number">0</span>], i])</span><br><span class="line">    y2.append(cornspect[rd[<span class="number">1</span>], i])</span><br><span class="line">    y3.append(cornspect[rd[<span class="number">2</span>], i])</span><br><span class="line">    y4.append(cornspect[rd[<span class="number">3</span>], i])</span><br><span class="line">    y5.append(cornspect[rd[<span class="number">4</span>], i])</span><br><span class="line"><span class="comment"># 导入字体</span></span><br><span class="line">matplotlib.rc(<span class="string">&quot;font&quot;</span>,family=<span class="string">&#x27;DengXian&#x27;</span>)</span><br><span class="line"><span class="comment"># 绘制图像</span></span><br><span class="line">fig=plt.figure(<span class="number">1</span>)</span><br><span class="line">plt.plot(x,y1,label=<span class="built_in">str</span>(rd[<span class="number">0</span>])+<span class="string">&#x27;号样本&#x27;</span>)</span><br><span class="line">plt.plot(x,y2,label=<span class="built_in">str</span>(rd[<span class="number">1</span>])+<span class="string">&#x27;号样本&#x27;</span>)</span><br><span class="line">plt.plot(x,y3,label=<span class="built_in">str</span>(rd[<span class="number">2</span>])+<span class="string">&#x27;号样本&#x27;</span>)</span><br><span class="line">plt.plot(x,y4,label=<span class="built_in">str</span>(rd[<span class="number">3</span>])+<span class="string">&#x27;号样本&#x27;</span>)</span><br><span class="line">plt.plot(x,y5,label=<span class="built_in">str</span>(rd[<span class="number">4</span>])+<span class="string">&#x27;号样本&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加图例</span></span><br><span class="line">plt.legend()</span><br><span class="line"><span class="comment"># 添加网格</span></span><br><span class="line">plt.grid(linestyle=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加坐标轴名称</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;波长/nm&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;吸光率&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 绘制蛋白质等</span></span><br><span class="line">plt.clf()</span><br><span class="line"><span class="comment"># 导入玉米特征矩阵</span></span><br><span class="line">cornprop=data[<span class="string">&#x27;cornprop&#x27;</span>]</span><br><span class="line"><span class="comment"># 水分</span></span><br><span class="line">Moisture=cornprop[:,<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 油脂</span></span><br><span class="line">Oil=cornprop[:,<span class="number">1</span>]</span><br><span class="line"><span class="comment"># 蛋白质</span></span><br><span class="line">Protein=cornprop[:,<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 淀粉</span></span><br><span class="line">Starch=cornprop[:,<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 随机抽取绘制饼图</span></span><br><span class="line">plt.pie(cornprop[rd[<span class="number">4</span>],:],labels=[<span class="string">&#x27;Moisture&#x27;</span>,<span class="string">&#x27;Oil&#x27;</span>,<span class="string">&#x27;Protein &#x27;</span>,<span class="string">&#x27;Starch&#x27;</span>],explode=(<span class="number">0</span>, <span class="number">0.2</span>, <span class="number">0</span>, <span class="number">0</span>),autopct=<span class="string">&#x27;%.2f%%&#x27;</span>)</span><br><span class="line">plt.title(<span class="built_in">str</span>(rd[<span class="number">4</span>])+<span class="string">&#x27;号样本的化学成分饼图&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line">plt.clf()</span><br><span class="line"><span class="comment"># 生成一个序号</span></span><br><span class="line">x=np.linspace(<span class="number">1</span>,<span class="number">80</span>,<span class="number">80</span>)</span><br><span class="line"><span class="comment"># 绘制不同化学成分的比较</span></span><br><span class="line">plt.plot(x,Moisture,label=<span class="string">&#x27;水分&#x27;</span>)</span><br><span class="line">plt.plot(x,Oil,label=<span class="string">&#x27;油脂&#x27;</span>)</span><br><span class="line">plt.plot(x,Protein,label=<span class="string">&#x27;蛋白质&#x27;</span>)</span><br><span class="line">plt.plot(x,Starch,label=<span class="string">&#x27;淀粉&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加标题</span></span><br><span class="line">plt.title(<span class="string">&#x27;化学成分对比图&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加坐标轴</span></span><br><span class="line">plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加图例</span></span><br><span class="line">plt.legend(loc=<span class="string">&#x27;right&#x27;</span>)</span><br><span class="line"><span class="comment"># 添加网格</span></span><br><span class="line">plt.grid(linestyle=<span class="string">&#x27;-.&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.clf()</span><br><span class="line"><span class="comment"># 求各个属性均值</span></span><br><span class="line">Moisture_ave=np.mean(Moisture)</span><br><span class="line">Oil_ave=np.mean(Oil)</span><br><span class="line">Protein_ave=np.mean(Protein)</span><br><span class="line">Starch_ave=np.mean(Starch)</span><br><span class="line"><span class="comment"># 设置权重</span></span><br><span class="line">weight=[Moisture_ave,Oil_ave,Protein_ave,Starch_ave]</span><br><span class="line"><span class="comment"># 设置序列点</span></span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 绘制柱状图</span></span><br><span class="line">plt.barh(x,weight,tick_label=[<span class="string">&#x27;Moisture&#x27;</span>,<span class="string">&#x27;Oil&#x27;</span>,<span class="string">&#x27;Protein &#x27;</span>,<span class="string">&#x27;Starch&#x27;</span>])</span><br><span class="line">plt.ylabel(<span class="string">&#x27;Attribute&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;Attribute_mean&#x27;</span>)</span><br><span class="line">plt.title(<span class="string">&#x27;各属性均值图&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>根据样本，可大概观察出1400波长以上透光率相对变化比较明显</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221002234045488.png" alt="image-20221002234045488"  /><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221002234758742.png" alt="image-20221002234758742"  /></p><p>各属性对比饼图，属性均值图：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221002234112149.png" alt="image-20221002234112149"  /></p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221002234218414.png" alt="image-20221002234218414"  /></p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221003002332397.png"alt="image-20221003002332397" /><figcaption aria-hidden="true">image-20221003002332397</figcaption></figure><h2 id="总结-1">总结</h2><p>mat数据集中可能存在结构体，通过scipy导入后，会自动将结构体转换为ndarray的结构数组；会将所有属性统一封装成dict，通过k-v取出。</p><h1 id="实验三-python矩阵运算">实验三 Python矩阵运算</h1><h2 id="实验目的-2">实验目的</h2><ol type="1"><li>掌握Python中的矩阵运算</li><li>尝试使用特征值分解协方差矩阵的方式进行降维</li></ol><h2 id="实验场地与设备-2">实验场地与设备</h2><p>实验室4074</p><h2 id="实验方式-2">实验方式</h2><p>程序设计</p><h2 id="实验设计-2">实验设计</h2><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/%E5%AE%9E%E9%AA%8C%E4%B8%89.png"alt="实验三" /><figcaption aria-hidden="true">实验三</figcaption></figure><h2 id="实验内容-2">实验内容</h2><h3 id="矩阵乘积">矩阵乘积</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">基本矩阵运算练习</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 矩阵乘法</span></span><br><span class="line">x=np.linspace(<span class="number">0</span>,<span class="number">8</span>,<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">y=np.linspace(<span class="number">1</span>,<span class="number">9</span>,<span class="number">9</span>).reshape(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 内积</span></span><br><span class="line">innerZ=np.inner(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵内积：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(innerZ)</span><br><span class="line"><span class="comment"># 张量积</span></span><br><span class="line">outerZ=np.outer(x,y)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵张量积：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(outerZ)</span><br><span class="line"><span class="comment"># 线性代数矩阵乘法</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;线性代数矩阵乘法&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.dot(x,y))</span><br></pre></td></tr></table></figure><p>运行结果：<img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016202747098.png" alt="image-20221016202747098" style="zoom: 67%;" /></p><h3 id="范数">范数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范数</span></span><br><span class="line"><span class="comment"># 初始化一个向量</span></span><br><span class="line">a=np.linspace(<span class="number">0</span>,<span class="number">9</span>,<span class="number">10</span>)</span><br><span class="line"><span class="comment"># 向量二范数</span></span><br><span class="line">a_norm = np.linalg.norm(a,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;向量a的二范数为&quot;</span>,a_norm)</span><br><span class="line"><span class="comment"># 矩阵二范数</span></span><br><span class="line">x_norm =np.linalg.norm(x,<span class="number">2</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵x的二范数为&quot;</span>,x_norm)</span><br><span class="line"><span class="comment"># 向量p范数</span></span><br><span class="line">a_norm = np.linalg.norm(a,np.inf) <span class="comment">#调用np中的变量inf表示无穷</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;向量a的p范数为&quot;</span>,a_norm)</span><br><span class="line"><span class="comment"># 矩阵p范数</span></span><br><span class="line">x_norm =np.linalg.norm(x,np.inf)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵x的二范数为&quot;</span>,x_norm)</span><br></pre></td></tr></table></figure><p>运行结果为：<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016202949373.png"alt="image-20221016202949373" /></p><h3 id="迹">迹</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 矩阵的迹</span></span><br><span class="line">x_trace = np.trace(x)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;矩阵x的迹:&quot;</span>,x_trace)</span><br></pre></td></tr></table></figure><p>运行结果为：<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016203045259.png"alt="image-20221016203045259" /></p><h3 id="奇异值分解">奇异值分解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">import</span> seaborn <span class="keyword">as</span> sns</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">data=sio.loadmat(<span class="string">&quot;NIRcorn.mat&quot;</span>)</span><br><span class="line"><span class="comment"># 获取玉米化学成分含量数据</span></span><br><span class="line">cornprop=data[<span class="string">&#x27;cornprop&#x27;</span>]</span><br><span class="line">cornprop=np.array(cornprop)</span><br><span class="line"><span class="comment"># 数据标准化</span></span><br><span class="line">scaler = StandardScaler(copy=<span class="literal">True</span>)</span><br><span class="line">cornprop=scaler.fit_transform(cornprop)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机抽样</span></span><br><span class="line"><span class="comment"># 随机抽取6个样本</span></span><br><span class="line">ran=np.random.randint(<span class="number">0</span>,<span class="number">80</span>,<span class="number">6</span>)</span><br><span class="line">cornpropSample1=cornprop[ran][:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;随机抽取6个样本结果&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cornpropSample1)</span><br><span class="line"><span class="comment"># 奇异值分解</span></span><br><span class="line">u1,e1,v1=np.linalg.svd(cornpropSample1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;左矩阵U：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(u1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;奇异值为：&quot;</span>,e1)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;右矩阵V^T：&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(np.transpose(v1))</span><br></pre></td></tr></table></figure><p>运行结果为：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016203239743.png" alt="image-20221016203239743" style="zoom:67%;" /></p><h3 id="特征值和奇异值比较">特征值和奇异值比较</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">随机抽取四个样本，对奇异值和特征值进行对比</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 随机抽取4个</span></span><br><span class="line">ran1=np.random.randint(<span class="number">0</span>,<span class="number">80</span>,<span class="number">4</span>)</span><br><span class="line">cornpropSample2=cornprop[ran1][:]</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;随机抽取4个样本结果&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cornpropSample2)</span><br><span class="line"><span class="comment"># 奇异值分解</span></span><br><span class="line">u2,e2,v2=np.linalg.svd(cornpropSample2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;奇异值：&quot;</span>,e2)</span><br><span class="line"><span class="comment"># 判断是否能做特征分解</span></span><br><span class="line"><span class="comment"># 验证rank是否为4</span></span><br><span class="line"><span class="keyword">if</span> np.linalg.matrix_rank(cornpropSample2)==<span class="number">4</span>:</span><br><span class="line">    evalue=np.linalg.eigvals(cornpropSample2)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;特征值：&quot;</span>,evalue)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;秩为：&quot;</span>,np.linalg.matrix_rank(cornpropSample2))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;为不满秩矩阵，无法进行特征分解&quot;</span>)</span><br></pre></td></tr></table></figure><p>运行结果为：<img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016203500623.png" alt="image-20221016203500623" style="zoom:80%;" /><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016203531499.png" alt="image-20221016203531499" style="zoom:80%;" /></p><p>结果表明，不是任何一个方阵都能使得奇异值和特征值，奇异值代表的是最大范围的线性变换程度，特征值代表的线性变换时的方向不变量。</p><h3 id="相关性分析">相关性分析</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">进行各个化学成分间的相关性分析</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 求协方差矩阵</span></span><br><span class="line">cov=np.cov(cornprop.transpose())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;协方差矩阵&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(cov)</span><br><span class="line"><span class="comment"># 可视化</span></span><br><span class="line">plt.figure(dpi=<span class="number">120</span>)</span><br><span class="line">sns.heatmap(data=cov,</span><br><span class="line">            cmap=plt.get_cmap(<span class="string">&#x27;Greens_r&#x27;</span>),</span><br><span class="line">            xticklabels=[<span class="string">&#x27;Moisture&#x27;</span>,<span class="string">&#x27;Oil&#x27;</span>,<span class="string">&#x27;Protein &#x27;</span>,<span class="string">&#x27;Starch&#x27;</span>],</span><br><span class="line">            yticklabels=[<span class="string">&#x27;Moisture&#x27;</span>,<span class="string">&#x27;Oil&#x27;</span>,<span class="string">&#x27;Protein &#x27;</span>,<span class="string">&#x27;Starch&#x27;</span>]</span><br><span class="line">           )</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016204408714.png"alt="image-20221016204408714" /><figcaption aria-hidden="true">image-20221016204408714</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016204333850.png"alt="image-20221016204333850" /><figcaption aria-hidden="true">image-20221016204333850</figcaption></figure><p>简单观察，可以看出淀粉和蛋白质的呈现负相关且比较强烈，蛋白质和油脂之间的关系呈现正相关。</p><h3 id="pca的初步尝试">PCA的初步尝试</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">协方差可进一步深度挖掘，结合各种矩阵运算进行PCA</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 对协方差矩阵进行特征值分解</span></span><br><span class="line">cov_evalue,cov_vectors = np.linalg.eig(cov)</span><br><span class="line"><span class="comment"># 然后选取前几个维度进行降维即可</span></span><br><span class="line"><span class="comment"># 构造特征矩阵</span></span><br><span class="line">smat = np.zeros((<span class="number">4</span>, <span class="number">4</span>))</span><br><span class="line">smat = np.diag(cov_evalue)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">p=np.dot(cov_vectors[:<span class="number">2</span>,:],cornpropSample2)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;降维后结果：&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(p)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20221016204707495.png"alt="image-20221016204707495" /><figcaption aria-hidden="true">image-20221016204707495</figcaption></figure><h2 id="总结-2">总结</h2><p>本次实验为下一节的PCA进行铺垫，也是绝大部分算法的基础。在学习奇异值分解和特征分解的时候，我通过查阅资料终于找到了解决从特征值到特征矩阵构建的方法，非常有成就感。</p><h1 id="实验三-最小二乘法">实验三 最小二乘法</h1><h2 id="实验目的-3">实验目的</h2><ol type="1"><li>生成正定矩阵联系线性回归</li><li>选取部分属性进行最小二乘算法</li><li>掌握最小二乘法</li></ol><h2 id="实验场地与设备-3">实验场地与设备</h2><p>实验室4074</p><h2 id="实验方式-3">实验方式</h2><p>程序设计</p><h2 id="实验设计-3">实验设计</h2><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204184750871.png" alt="image-20230204184750871" style="zoom: 50%;" /></p><h2 id="实验内容-3">实验内容</h2><h3 id="生成正定矩阵使用最小二乘">生成正定矩阵使用最小二乘</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">1.尝试网站代码应用</span></span><br><span class="line"><span class="string">2.理解源代码</span></span><br><span class="line"><span class="string">3.回归源码转化伪代码、流程图</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># 导入必要库</span></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets, linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, r2_score</span><br><span class="line"></span><br><span class="line"><span class="comment"># 导入数据集</span></span><br><span class="line">diabetes_X, diabetes_y = datasets.load_diabetes(return_X_y=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 简单分析数据集</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;x&quot;</span>,diabetes_X) <span class="comment"># 442*10</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;y&quot;</span>,diabetes_y) <span class="comment"># 1*442</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用一个x的特征</span></span><br><span class="line">diabetes_X = diabetes_X[:, np.newaxis, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分训练集和测试集</span></span><br><span class="line"><span class="comment"># x</span></span><br><span class="line">diabetes_X_train = diabetes_X[:-<span class="number">20</span>]</span><br><span class="line">diabetes_X_test = diabetes_X[-<span class="number">20</span>:]</span><br><span class="line"><span class="comment"># y</span></span><br><span class="line">diabetes_y_train = diabetes_y[:-<span class="number">20</span>]</span><br><span class="line">diabetes_y_test = diabetes_y[-<span class="number">20</span>:]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线性回归对象</span></span><br><span class="line">regr = linear_model.LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练线性回归模型</span></span><br><span class="line">regr.fit(diabetes_X_train, diabetes_y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 测试集预测</span></span><br><span class="line">diabetes_y_pred = regr.predict(diabetes_X_test)</span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">应该是某种误差，具体得看源码</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="comment"># The coefficients</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Coefficients: \n&quot;</span>, regr.coef_)</span><br><span class="line"><span class="comment"># The mean squared error</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Mean squared error: %.2f&quot;</span> % mean_squared_error(diabetes_y_test, diabetes_y_pred))</span><br><span class="line"><span class="comment"># The coefficient of determination: 1 is perfect prediction</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Coefficient of determination: %.2f&quot;</span> % r2_score(diabetes_y_test, diabetes_y_pred))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.scatter(diabetes_X_test, diabetes_y_test, color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">plt.plot(diabetes_X_test, diabetes_y_pred, color=<span class="string">&quot;blue&quot;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204182023479.png"alt="image-20230204182023479" /><figcaption aria-hidden="true">image-20230204182023479</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204182051171.png"alt="image-20230204182051171" /><figcaption aria-hidden="true">image-20230204182051171</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204184117890.png"alt="image-20230204184117890" /><figcaption aria-hidden="true">image-20230204184117890</figcaption></figure><h3 id="选取部分属性进行最小二乘算法">选取部分属性进行最小二乘算法</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> mean_squared_error, r2_score</span><br><span class="line"></span><br><span class="line">data=sio.loadmat(<span class="string">&quot;../NIRcorn.mat&quot;</span>)</span><br><span class="line"></span><br><span class="line">cornprop = data[<span class="string">&quot;cornprop&quot;</span>][:,<span class="number">0</span>].reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">m5spec=data[<span class="string">&#x27;m5spec&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="number">0</span>][:,<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建线性回归对象</span></span><br><span class="line">regr = linear_model.LinearRegression()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练线性回归模型</span></span><br><span class="line">regr.fit(cornprop,m5spec)</span><br><span class="line">y_pred = regr.predict(cornprop)</span><br><span class="line">plt.scatter(cornprop, m5spec, color=<span class="string">&quot;black&quot;</span>)</span><br><span class="line">plt.plot(cornprop, y_pred, color=<span class="string">&quot;blue&quot;</span>, linewidth=<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">plt.xticks(())</span><br><span class="line">plt.yticks(())</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204184257098.png"alt="image-20230204184257098" /><figcaption aria-hidden="true">image-20230204184257098</figcaption></figure><h2 id="总结-3">总结</h2><p>最小二乘法作为线性回归的基础，其数学推导十分重要，深刻理解了最小二乘才能初步理解高维空间中的空间变换以及相关的几何意义。</p><h1 id="实验四-主成分分析">实验四 主成分分析</h1><h2 id="实验目的-4">实验目的</h2><ol type="1"><li>掌握PCA算法原理</li><li>用python实现PCA降维</li><li>体会python面向对象的灵活</li></ol><h2 id="实验场地与设备-4">实验场地与设备</h2><p>实验室4074</p><h2 id="实验方式-4">实验方式</h2><p>程序设计</p><h2 id="实验设计-4">实验设计</h2><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204185133692.png"alt="image-20230204185133692" /><figcaption aria-hidden="true">image-20230204185133692</figcaption></figure><h2 id="实验内容-4">实验内容</h2><h3 id="伪代码">伪代码</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">input：data,n_components</span><br><span class="line">output：U，S</span><br><span class="line">-----------------------------------------</span><br><span class="line">Data_mean=np.mean(data)</span><br><span class="line">Data=np.substract(data,Data_mean)</span><br><span class="line">cov_X=np.cov(np.transpose(Data))</span><br><span class="line">U,S,V=np.linalg.svd(cov_X)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="python实现">python实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">from</span> sklearn.utils.extmath <span class="keyword">import</span> svd_flip</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCA</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="comment"># 初始化</span></span><br><span class="line">    np.set_printoptions(suppress=<span class="literal">True</span>)</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,components</span>):</span><br><span class="line">        self.components=components</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X</span>):</span><br><span class="line">        X_mean=np.mean(X)</span><br><span class="line">        X=np.subtract(X,X_mean)</span><br><span class="line">        cov_X=np.cov(np.transpose(X))</span><br><span class="line">        <span class="keyword">if</span> np.linalg.matrix_rank(cov_X)&lt;np.shape(cov_X)[<span class="number">0</span>]:</span><br><span class="line">            U,S,V=np.linalg.svd(cov_X)</span><br><span class="line">            U, V = svd_flip(U, V)</span><br><span class="line">            U=np.array(U[:self.components]).T</span><br><span class="line">            U *= S[:self.components]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            explained_variance_ = (S * S.T) / (np.shape(X)[<span class="number">0</span>] - <span class="number">1</span>)</span><br><span class="line">            total_var = explained_variance_.<span class="built_in">sum</span>()</span><br><span class="line">            explained_variance_ratio_ = explained_variance_ / total_var</span><br><span class="line">            self.explained_variance_ratio_ = explained_variance_ratio_[:self.components]</span><br><span class="line">            <span class="keyword">return</span> U,S</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            eigValue,eigVector=np.linalg.eig(cov_X)</span><br><span class="line">            index = np.argsort(-eigValue)</span><br><span class="line">            <span class="keyword">if</span> self.components &gt; np.shape(X)[<span class="number">1</span>]:</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;features is lower than commponents&#x27;</span>)</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                T = np.array(eigVector[index[:self.components]]).T</span><br><span class="line">                P = np.dot(X,T)</span><br><span class="line">                <span class="comment"># 求解解释变量</span></span><br><span class="line">                <span class="comment"># 要不要根据对抽样统计做方差的无偏估计</span></span><br><span class="line">                <span class="comment"># 使用特征值分解一旦不满秩，就会出现复数解</span></span><br><span class="line">                explained_variance_ = (eigValue * eigValue.T)/(np.shape(X)[<span class="number">0</span>]-<span class="number">1</span>)</span><br><span class="line">                total_var = explained_variance_.<span class="built_in">sum</span>()</span><br><span class="line">                explained_variance_ratio_ = explained_variance_ / total_var</span><br><span class="line">                self.explained_variance_ratio_=explained_variance_ratio_[:self.components]</span><br><span class="line">                <span class="keyword">return</span> P,T</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line"></span><br><span class="line">    data = sio.loadmat(<span class="string">&quot;../NIRcorn.mat&quot;</span>)</span><br><span class="line"></span><br><span class="line">    cornprop = data[<span class="string">&quot;cornprop&quot;</span>]</span><br><span class="line">    m5spec = data[<span class="string">&#x27;m5spec&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    y = data[<span class="string">&#x27;cornprop&#x27;</span>][:, [<span class="number">0</span>]]</span><br><span class="line">    x = m5spec</span><br><span class="line"></span><br><span class="line">    pca=PCA(<span class="number">2</span>)</span><br><span class="line">    U,S=pca.fit(x)</span><br><span class="line">    <span class="built_in">print</span>(</span><br><span class="line">        <span class="string">&quot;explained variance ratio (first two components): %s&quot;</span></span><br><span class="line">        % <span class="built_in">str</span>(pca.explained_variance_ratio_)</span><br><span class="line">    )</span><br></pre></td></tr></table></figure><p>explained variance ratio (first two components): [0.999940010.00005929]</p><h3 id="调用pca降维鸢尾花">调用PCA降维鸢尾花</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line"></span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line">target_names = iris.target_names</span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">X_r = pca.fit(X).transform(X)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Percentage of variance explained for each components</span></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="string">&quot;explained variance ratio (first two components): %s&quot;</span></span><br><span class="line">    % <span class="built_in">str</span>(pca.explained_variance_ratio_)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">colors = [<span class="string">&quot;navy&quot;</span>, <span class="string">&quot;turquoise&quot;</span>, <span class="string">&quot;darkorange&quot;</span>]</span><br><span class="line">lw = <span class="number">2</span></span><br><span class="line"><span class="keyword">for</span> color, i, target_name <span class="keyword">in</span> <span class="built_in">zip</span>(colors, [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], target_names):</span><br><span class="line">    plt.scatter(</span><br><span class="line">        <span class="comment"># y==i是一个推导式，本质上是返回一个布尔数组，从而达成筛选的目的</span></span><br><span class="line">        X_r[y == i, <span class="number">0</span>], X_r[y == i, <span class="number">1</span>], color=color, alpha=<span class="number">0.8</span>, lw=lw, label=target_name</span><br><span class="line">    )</span><br><span class="line">plt.legend(loc=<span class="string">&quot;best&quot;</span>, shadow=<span class="literal">False</span>, scatterpoints=<span class="number">1</span>)</span><br><span class="line">plt.title(<span class="string">&quot;PCA of IRIS dataset&quot;</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204185710362.png"alt="image-20230204185710362" /><figcaption aria-hidden="true">image-20230204185710362</figcaption></figure><h3 id="调用pca降维nircorn">调用pca降维NIRcorn</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">data=sio.loadmat(<span class="string">&quot;../NIRcorn.mat&quot;</span>)</span><br><span class="line"></span><br><span class="line">cornprop = data[<span class="string">&quot;cornprop&quot;</span>]</span><br><span class="line">m5spec=data[<span class="string">&#x27;m5spec&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># x_mean=np.mean(m5spec)</span></span><br><span class="line"><span class="comment"># x_center=np.subtract(m5spec,x_mean)</span></span><br><span class="line"></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">x = pca.fit(m5spec).transform(m5spec)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(</span><br><span class="line">    <span class="string">&quot;explained variance ratio (first two components): %s&quot;</span></span><br><span class="line">    % <span class="built_in">str</span>(pca.explained_variance_ratio_)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">plt.scatter(x[:,<span class="number">0</span>],x[:,<span class="number">1</span>])</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204185800726.png" /></p><h2 id="总结-4">总结</h2><p>主成分分析是基于投影的方法，而衡量投影距离的就是协方差矩阵。而对于协方差矩阵的分解方式就显得尤为重要，我自己实现的PCA与sklearn种出现显著差异的原因就是在奇异值分解的方式。sklearn采用的是随机奇异值分解。</p><h1 id="实验五-主成分回归">实验五 主成分回归</h1><h2 id="实验目的-5">实验目的</h2><ol type="1"><li>掌握PCR算法原理</li><li>掌握交叉验证算法应用；</li><li>体会python面向对象的灵活</li></ol><h2 id="实验场地与设备-5">实验场地与设备</h2><p>实验室4074</p><h2 id="实验方式-5">实验方式</h2><p>程序设计</p><h2 id="实验设计-5">实验设计</h2><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204194417158.png" alt="image-20230204194417158" style="zoom:50%;" /></p><h2 id="实验内容-5">实验内容</h2><h3 id="伪代码-1">伪代码</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PCR.fit</span><br><span class="line">-----------------------------</span><br><span class="line">input:X,y,n_components</span><br><span class="line">output:P,b</span><br><span class="line">------------------------------</span><br><span class="line">P = PCA(X,n_components)</span><br><span class="line">T = X*P</span><br><span class="line">b = LS.fit(T,y)</span><br></pre></td></tr></table></figure><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PCR.predict</span><br><span class="line">-----------------------------</span><br><span class="line">input:X,P,b</span><br><span class="line">output:y_predict</span><br><span class="line">-----------------------------</span><br><span class="line">T = X*P</span><br><span class="line">y_predict = T*b</span><br></pre></td></tr></table></figure><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">PCR.cv</span><br><span class="line">-----------------------------</span><br><span class="line">input:X,y,max_pcs,k</span><br><span class="line">output:best_pcs</span><br><span class="line">-----------------------------X_train,X_val,y_train,y_val = cross validation.split(X,y,k)</span><br><span class="line">  <span class="keyword">for</span> n_pcs <span class="keyword">in</span> range(<span class="number">2</span>,max_pcs+<span class="number">1</span>):</span><br><span class="line">   y_predict = [ ]</span><br><span class="line">   <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">0</span>,k):</span><br><span class="line">   P,b = PCR.fit(X_train=X_k≠i,y_train=y_k≠i,n_pcs)</span><br><span class="line">   ypre = PCR.predict(X_val=X_k=i,P,b)</span><br><span class="line">   y_predict.append(ypre)</span><br><span class="line">   RMSE(y,y_predict,len(y))</span><br><span class="line">  best_pcs = RMSE.<span class="keyword">index</span>(min(RMSE))</span><br><span class="line"> return best_pcs</span><br></pre></td></tr></table></figure><h3 id="python实现-1"><strong>Python实现</strong></h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line"><span class="comment"># from sklearn.decomposition import PCA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cross_Validation</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y, n_folds, max_components</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.n_folds = n_folds</span><br><span class="line">        self.max_components = max_components</span><br><span class="line">        self.n = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">CV</span>(<span class="params">self</span>):</span><br><span class="line">        kf = cross_validation.KFold(self.n, self.n_folds)</span><br><span class="line">        x_train=[]</span><br><span class="line">        x_test=[]</span><br><span class="line">        y_train=[]</span><br><span class="line">        y_test=[]</span><br><span class="line">        <span class="keyword">for</span> train_index,test_index <span class="keyword">in</span> kf:</span><br><span class="line">            xtr, xte = self.x[train_index], self.x[test_index]</span><br><span class="line">            ytr, yte = self.y[train_index], self.y[test_index]</span><br><span class="line">            x_train.append(xtr)</span><br><span class="line">            x_test.append(xte)</span><br><span class="line">            y_train.append(ytr)</span><br><span class="line">            y_test.append(yte)</span><br><span class="line">        <span class="keyword">return</span> x_train, x_test, y_train, y_test</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">from</span> Cross_Validation <span class="keyword">import</span> Cross_Validation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PCR</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_components</span>):</span><br><span class="line">        self.max_components=max_components</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,y,best_components</span>):</span><br><span class="line">        self.x_mean = np.mean(X, axis=<span class="number">0</span>)</span><br><span class="line">        self.y_mean = np.mean(y, axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># sklearn中的pca自带中心化处理</span></span><br><span class="line">        pca=PCA(n_components=best_components)</span><br><span class="line">        pca=pca.fit(X)</span><br><span class="line">        X_r=pca.transform(X)</span><br><span class="line">        b=np.linalg.lstsq(X_r,np.subtract(y,self.y_mean))[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">return</span> b,pca</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pridict</span>(<span class="params">self,b,X,pca</span>):</span><br><span class="line">        T=pca.transform(X)</span><br><span class="line">        y_pre = np.dot(T, b)</span><br><span class="line">        y_predict = np.add(y_pre, self.y_mean)</span><br><span class="line">        <span class="keyword">return</span> y_predict</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cv_pridict</span>(<span class="params">self,X,y,n_fold,</span>):</span><br><span class="line">        cv = Cross_Validation(X,y,n_fold,self.max_components)</span><br><span class="line">        X_train, X_test, y_train, y_test = cv.CV()</span><br><span class="line">        y_allPredict=np.ones((<span class="number">1</span>,self.max_components))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_fold):</span><br><span class="line">            y_predict=np.zeros((y_test[i].shape[<span class="number">0</span>],self.max_components))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.max_components):</span><br><span class="line">                b,pca=self.fit(X_train[i],y_train[i],j+<span class="number">1</span>)</span><br><span class="line">                y_pre=self.pridict(b,X_test[i],pca)</span><br><span class="line">                y_predict[:,j]=y_pre.ravel()</span><br><span class="line"></span><br><span class="line">            y_allPredict=np.vstack((y_allPredict,y_predict))</span><br><span class="line">        y_allPredict=y_allPredict[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> y_allPredict,cv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">RMSE_CV</span>(<span class="params">self,y_allPredict, y_measure,cv</span>):</span><br><span class="line">        press = np.square(np.subtract(y_allPredict, y_measure))</span><br><span class="line">        press_all = np.<span class="built_in">sum</span>(press, axis=<span class="number">0</span>)</span><br><span class="line">        RMSECV = np.sqrt(press_all / cv.n)</span><br><span class="line">        min_RMSECV = <span class="built_in">min</span>(RMSECV)</span><br><span class="line">        comp_array = RMSECV.argsort()</span><br><span class="line">        comp_best = comp_array[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> RMSECV, min_RMSECV, comp_best</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_Select_comp</span>(<span class="params">self,RMSECV</span>):</span><br><span class="line">        x=np.linspace(<span class="number">1</span>,<span class="number">20</span>,<span class="number">20</span>)</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot(x,RMSECV)</span><br><span class="line">        plt.ylabel(RMSECV)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;n_comp&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = sio.loadmat(<span class="string">&quot;../NIRcorn.mat&quot;</span>)</span><br><span class="line"></span><br><span class="line">    cornprop = data[<span class="string">&quot;cornprop&quot;</span>]</span><br><span class="line">    m5spec = data[<span class="string">&#x27;m5spec&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    y = data[<span class="string">&#x27;cornprop&#x27;</span>][:, [<span class="number">0</span>]]</span><br><span class="line">    x=m5spec</span><br><span class="line">    y_mean=np.mean(y,axis=<span class="number">0</span>)</span><br><span class="line">    pcr=PCR(<span class="number">20</span>)</span><br><span class="line">    b,pca=pcr.fit(x,y,<span class="number">14</span>)</span><br><span class="line">    y_pre=pcr.pridict(b,x,pca)</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line">    <span class="built_in">print</span>(y_pre)</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    # 预测图显示</span></span><br><span class="line"><span class="string">    plt.figure()</span></span><br><span class="line"><span class="string">    plt.scatter(np.linspace(1,80,80),y_pre)</span></span><br><span class="line"><span class="string">    plt.scatter(np.linspace(1, 80, 80),y)</span></span><br><span class="line"><span class="string">    plt.show()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    y_pre,cv=pcr.cv_pridict(x,y,<span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(y_pre)</span><br><span class="line">    RMSEcv,min_RMSEcv,best_comp=pcr.RMSE_CV(y_pre,cv.y,cv)</span><br><span class="line">    <span class="built_in">print</span>(RMSEcv)</span><br><span class="line">    pcr.show_Select_comp(RMSEcv)</span><br><span class="line"><span class="comment"># &#x27;&#x27;&#x27;</span></span><br></pre></td></tr></table></figure><p>参数选择：<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204192233033.png"alt="image-20230204192233033" /></p><p>预测结果：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204192338375.png"alt="image-20230204192338375" /><figcaption aria-hidden="true">image-20230204192338375</figcaption></figure><h2 id="总结-5">总结</h2><p>主成分回归分析(PCR)，以主成分为自变量进行的回归分析。是分析多元共线性问题的一种方法，当自变量存在复共线性刚，用于改进最小二乘回归的统计分析方法。霍特林1933年首先用主成分分析相关结构，1965年马西提出主成分回归。</p><p>基本步骤：</p><p>（1）将自变量转换为标准分；</p><p>（2）求出这此标准分的主成分，去掉特征根很小的主成分；</p><p>（3）用最小二乘法作因变量对保留的主成分的回归；</p><p>（4）将回归方程中的主成分换成标准分的线性组合，得到由标准分给出的回归方程</p><p>在实现过程中，注意到一点，self在python面向对象的活用，可以大幅度减少变量定义，而且可以作为全局变量跳出循环中，非常好用。</p><h1 id="实验六-偏最小二乘算法">实验六 偏最小二乘算法</h1><h2 id="实验目的-6">实验目的</h2><ol type="1"><li>实现NIPALS算法并对nircorn数据集进行预测</li><li>掌握交叉验证算法应用；</li><li>实现PLS算法</li></ol><h2 id="实验场地与设备-6">实验场地与设备</h2><p>实验室4074</p><h2 id="实验方式-6">实验方式</h2><p>程序设计</p><h2 id="实验设计-6">实验设计</h2><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204194521892.png" alt="image-20230204194521892" style="zoom:50%;" /></p><h2 id="实验内容-6">实验内容</h2><h3 id="nipls伪代码">NIPLS伪代码</h3><figure class="highlight pascal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">NIPALS.py</span><br><span class="line">--------------------------------------------</span><br><span class="line">input: X,Y,n_comp</span><br><span class="line">output:P,Q,T,U,W,C</span><br><span class="line">--------------------------------------------</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(n_comp):</span><br><span class="line">    u_new=Y[i+<span class="number">1</span>]</span><br><span class="line">    u_old=np.ones((Y.shape[i+<span class="number">1</span>],<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> || u_new-u_old ||&gt;=<span class="number">0.0001</span>(极小值):</span><br><span class="line">        u_old=u_new</span><br><span class="line">        w = X^T * u_new / ( u_old^T * u_old )</span><br><span class="line">        w = w / sqrt(w^T * w)</span><br><span class="line">        t = X * w</span><br><span class="line">        c = Y * t /( t^T * t )</span><br><span class="line">        c = c / sqrt(c^T * c)</span><br><span class="line">        u_new = Y * c</span><br><span class="line"></span><br><span class="line">    p = X * t / ( t^T * t )</span><br><span class="line">    q = Y * c / ( c^T * c )</span><br><span class="line">    X1 = X - t * p^T</span><br><span class="line">    b1 = u_new^T * t / ( t^T * t )</span><br><span class="line">    Y1 = Y - b * t * q^T</span><br><span class="line"></span><br><span class="line">    B[n_comp,:]=b</span><br><span class="line">    P[:,n_comp]=p</span><br><span class="line">    Q[:,n_comp]=q</span><br><span class="line">    T[:,n_comp]=t</span><br><span class="line">    U[:,n_comp]=u_new</span><br><span class="line">    W[:,n_comp]=w</span><br><span class="line">    C[:,n_comp]=c</span><br><span class="line">--------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="nipls实现">NIPLS实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> numpy <span class="keyword">import</span> linalg</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NIPALS</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, max_pcs, sigma=<span class="number">0.0001</span></span>):</span><br><span class="line"></span><br><span class="line">        self.max_pcs = max_pcs</span><br><span class="line">        self.sigma = sigma</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, X, Y</span>):</span><br><span class="line">        E, F = X, Y</span><br><span class="line">        P = np.mat(np.ones((X.shape[<span class="number">1</span>], self.max_pcs)))  <span class="comment"># X载荷矩阵——P</span></span><br><span class="line">        T = np.mat(np.ones((X.shape[<span class="number">0</span>], self.max_pcs)))  <span class="comment"># X得分矩阵——T</span></span><br><span class="line">        W = np.mat(np.ones((X.shape[<span class="number">1</span>], self.max_pcs)))  <span class="comment"># X权重矩阵——W</span></span><br><span class="line">        Q = np.mat(np.ones((Y.shape[<span class="number">1</span>], self.max_pcs)))  <span class="comment"># Y载荷矩阵——Q</span></span><br><span class="line">        U = np.mat(np.ones((X.shape[<span class="number">0</span>], self.max_pcs)))  <span class="comment"># Y得分矩阵——U</span></span><br><span class="line">        C = np.mat(np.ones((Y.shape[<span class="number">1</span>], self.max_pcs)))  <span class="comment"># Y权重矩阵C</span></span><br><span class="line">        B = np.ones((self.max_pcs, X.shape[<span class="number">1</span>], Y.shape[<span class="number">1</span>]))</span><br><span class="line">        <span class="keyword">for</span> pcs <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, self.max_pcs):</span><br><span class="line"></span><br><span class="line">            t_old, t_new = np.zeros((X.shape[<span class="number">0</span>], <span class="number">1</span>)), np.ones((X.shape[<span class="number">0</span>], <span class="number">1</span>))  <span class="comment"># (64,1)</span></span><br><span class="line">            p_old, p_new = np.ones((X.shape[<span class="number">1</span>], <span class="number">1</span>)), np.ones((X.shape[<span class="number">1</span>], <span class="number">1</span>))  <span class="comment"># (700,1)</span></span><br><span class="line">            w_old, w_new = np.ones((X.shape[<span class="number">1</span>], <span class="number">1</span>)), np.ones((X.shape[<span class="number">1</span>], <span class="number">1</span>))  <span class="comment"># (700,1)</span></span><br><span class="line">            q_old, q_new = np.ones((Y.shape[<span class="number">1</span>], <span class="number">1</span>)), np.ones((Y.shape[<span class="number">1</span>], <span class="number">1</span>))  <span class="comment"># (4,1)</span></span><br><span class="line">            u_old, u_new = np.mat(Y[:, <span class="number">0</span>]).T, np.ones((X.shape[<span class="number">0</span>], <span class="number">1</span>))  <span class="comment"># (64,1)</span></span><br><span class="line">            <span class="keyword">while</span> (np.sqrt(np.<span class="built_in">sum</span>(np.square(np.subtract(t_new, t_old)) / t_new.shape[<span class="number">0</span>])) &gt; self.sigma):</span><br><span class="line">                t_old = t_new</span><br><span class="line">                w_old = (np.dot(u_old.T, X) / np.dot(u_old.T, u_old)).T</span><br><span class="line">                w_new = (w_old.T / np.sqrt(np.dot(w_old.T, w_old))).T</span><br><span class="line">                t_new = np.dot(X, w_new) / np.dot(w_new.T, w_new)</span><br><span class="line">                q_old = (np.dot(t_new.T, Y) / np.dot(t_new.T, t_new)).T</span><br><span class="line">                q_new = (q_old.T / np.linalg.norm(q_old.T)).T</span><br><span class="line">                u_new = np.dot(Y, q_new) / np.dot(q_new.T, q_new)</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Y.shape[<span class="number">1</span>] == <span class="number">1</span>):  <span class="comment"># 判断Y是否是一维</span></span><br><span class="line">                p_old = (np.dot(t_new.T, X) / np.dot(t_new.T, t_new)).T</span><br><span class="line">                p_new = (p_old.T / np.linalg.norm(p_old.T)).T</span><br><span class="line">                t_new = t_old * np.linalg.norm(p_old.T)</span><br><span class="line">                w_new = (w_old.T * np.linalg.norm(p_old.T)).T</span><br><span class="line"></span><br><span class="line">            b = np.dot(np.dot(w_new, linalg.inv(np.dot(p_new.T, w_new))), q_new.T)</span><br><span class="line"></span><br><span class="line">            P[:, pcs] = p_new  <span class="comment"># 保存p</span></span><br><span class="line">            T[:, pcs] = t_new  <span class="comment"># 保存t</span></span><br><span class="line">            W[:, pcs] = w_new  <span class="comment"># 保存w</span></span><br><span class="line">            B[pcs, ::] = b  <span class="comment"># 保存b</span></span><br><span class="line">            Q[:, pcs] = q_new  <span class="comment"># 保存q</span></span><br><span class="line">            U[:, pcs] = u_new  <span class="comment"># 保存u</span></span><br><span class="line">            E = E - np.dot(t_new, p_new.T)</span><br><span class="line">            F = F - np.dot(t_new, q_new.T)</span><br><span class="line">            self.X = E</span><br><span class="line">            self.Y = F</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> P, T, W, Q, U, B</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X, B, best_pcs</span>):</span><br><span class="line">        B_new = np.zeros((B[<span class="number">0</span>].shape[<span class="number">0</span>], B[<span class="number">0</span>].shape[<span class="number">1</span>]))</span><br><span class="line">        B_new[:] = B[best_pcs - <span class="number">1</span>]</span><br><span class="line">        Y_predict = np.dot(X, B_new)</span><br><span class="line">        <span class="keyword">return</span> Y_predict</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">RMSE</span>(<span class="params">y, y_predict, k</span>):</span><br><span class="line">    press = np.square(np.subtract(y, y_predict))</span><br><span class="line">    press_all = np.<span class="built_in">sum</span>(press, axis=<span class="number">0</span>)</span><br><span class="line">    RMSE = np.sqrt(press_all / k)</span><br><span class="line">    <span class="keyword">return</span> RMSE</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 导入数据</span></span><br><span class="line">    data = sio.loadmat(<span class="string">&quot;../NIRcorn.mat&quot;</span>)</span><br><span class="line">    cornprop = data[<span class="string">&quot;cornprop&quot;</span>]</span><br><span class="line">    Y = cornprop</span><br><span class="line">    <span class="built_in">print</span>(np.shape(Y))</span><br><span class="line">    A = data[<span class="string">&quot;m5spec&quot;</span>]</span><br><span class="line">    m5spec = A[<span class="string">&quot;data&quot;</span>][<span class="number">0</span>][<span class="number">0</span>]  <span class="comment"># 80*700矩阵</span></span><br><span class="line">    <span class="comment"># 划分数据集</span></span><br><span class="line">    X_train, X_test, y_train, y_test = train_test_split(m5spec, Y, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;X_train:&quot;</span>, X_train.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;X_test:&quot;</span>, X_test.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_train:&quot;</span>, y_train.shape)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;y_test:&quot;</span>, y_test.shape)</span><br><span class="line">    <span class="comment"># 将训练集中心化</span></span><br><span class="line">    X_mean = np.mean(X_train, axis=<span class="number">0</span>)</span><br><span class="line">    X_center = np.subtract(X_train, X_mean)</span><br><span class="line">    Y_mean = np.mean(y_train, axis=<span class="number">0</span>)</span><br><span class="line">    Y_center = np.subtract(y_train, Y_mean)</span><br><span class="line">    X_test_mean = np.mean(X_test, axis=<span class="number">0</span>)</span><br><span class="line">    X_test_center = np.subtract(X_test, X_test_mean)</span><br><span class="line">    pls = NIPALS(<span class="number">5</span>)</span><br><span class="line">    P, T, W, Q, U, B = pls.fit(X_center, Y_center)</span><br><span class="line">    Y_predict = pls.predict(X_test_center, B, <span class="number">2</span>)</span><br><span class="line">    Ypre = Y_predict + Y_mean</span><br><span class="line">    rmse = RMSE(y_test.ravel(), Ypre.ravel(), Y_center.shape[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Y_predict:&quot;</span>, Ypre)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;rmse:&quot;</span>, rmse)</span><br></pre></td></tr></table></figure><p>rmse: 0.5119355259810657</p><h3 id="pls实现">PLS实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.cross_decomposition <span class="keyword">import</span> PLSRegression</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> Cross_Validation <span class="keyword">import</span> Cross_Validation</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">pls</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,max_comp</span>):</span><br><span class="line">        self.max_comp=max_comp</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,Y,n_comp</span>):</span><br><span class="line">        pls=PLSRegression(n_components=n_comp)</span><br><span class="line">        pls.fit(X,Y)</span><br><span class="line">        <span class="keyword">return</span> pls</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X,pls</span>):</span><br><span class="line">        <span class="keyword">return</span> pls.predict(X)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cv_predict</span>(<span class="params">self,X,y,n_fold</span>):</span><br><span class="line">        cv = Cross_Validation(X, y, n_fold, self.max_comp)</span><br><span class="line">        X_train, X_test, y_train, y_test = cv.CV()</span><br><span class="line">        y_allPredict = np.ones((<span class="number">1</span>, self.max_comp))</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_fold):</span><br><span class="line">            y_predict = np.zeros((y_test[i].shape[<span class="number">0</span>], self.max_comp))</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(self.max_comp):</span><br><span class="line">                pls=self.fit(X_train[i],y_train[i],j+<span class="number">1</span>)</span><br><span class="line">                y_pre=self.predict(X_test[i],pls)</span><br><span class="line">                y_predict[:,j]=y_pre.ravel()</span><br><span class="line">            y_allPredict = np.vstack((y_allPredict, y_predict))</span><br><span class="line">        y_allPredict = y_allPredict[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> y_allPredict, cv,y_test,y_train,X_test,X_train</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">RMSE_CV</span>(<span class="params">self, y_allPredict, y_measure, cv</span>):</span><br><span class="line">        press = np.square(np.subtract(y_allPredict, y_measure))</span><br><span class="line">        press_all = np.<span class="built_in">sum</span>(press, axis=<span class="number">0</span>)</span><br><span class="line">        RMSECV = np.sqrt(press_all / cv.n)</span><br><span class="line">        min_RMSECV = <span class="built_in">min</span>(RMSECV)</span><br><span class="line">        comp_array = RMSECV.argsort()</span><br><span class="line">        comp_best = comp_array[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> RMSECV, min_RMSECV, comp_best</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_Select_comp</span>(<span class="params">self,RMSECV</span>):</span><br><span class="line">        x=np.linspace(<span class="number">1</span>,<span class="number">20</span>,<span class="number">20</span>)</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot(x,RMSECV,marker=<span class="string">&#x27;^&#x27;</span>,markersize=<span class="number">10</span>,markerfacecolor=<span class="string">&#x27;orange&#x27;</span>,color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;num_components&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;RMSECV&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_predict</span>(<span class="params">self,y</span>):</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot([<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], [<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], label=<span class="string">&#x27;y=x&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        plt.scatter(y, y_pre, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;y_all&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;measure value&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;predict value&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_predict</span>(<span class="params">self,y,y_pre</span>):</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot([<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], [<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], label=<span class="string">&#x27;y=x&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        plt.scatter(y, y_pre, color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;y_all&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;measure value&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;predict value&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_cv_predict</span>(<span class="params">self,y,x_test,y_test,y_train,x_train,pls</span>):</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot([<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], [<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], label=<span class="string">&#x27;y=x&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        plt.scatter(y_test[<span class="number">0</span>],self.predict(x_test[<span class="number">0</span>],pls), color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;test set&#x27;</span>)</span><br><span class="line">        plt.scatter(y_train[<span class="number">0</span>],self.predict(x_train[<span class="number">0</span>],pls), color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;train set&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;measure value&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;predict value&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = sio.loadmat(<span class="string">&quot;../NIRcorn.mat&quot;</span>)</span><br><span class="line"></span><br><span class="line">    cornprop = data[<span class="string">&quot;cornprop&quot;</span>]</span><br><span class="line">    m5spec = data[<span class="string">&#x27;m5spec&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    y = data[<span class="string">&#x27;cornprop&#x27;</span>][:, [<span class="number">0</span>]]</span><br><span class="line">    x=m5spec</span><br><span class="line"></span><br><span class="line">    pls=pls(<span class="number">20</span>)</span><br><span class="line">    pls1=pls.fit(x,y,<span class="number">14</span>)</span><br><span class="line">    y_pre=pls.predict(x,pls1)</span><br><span class="line">    <span class="built_in">print</span>(y)</span><br><span class="line">    <span class="built_in">print</span>(y_pre)</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot([<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)],[<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)],label=<span class="string">&#x27;y=x&#x27;</span>,color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">    plt.scatter(y, y_pre,color=<span class="string">&#x27;red&#x27;</span>,label=<span class="string">&#x27;y_all&#x27;</span>)</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;measure value&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;predict value&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    y_pre, cv,y_test,y_train,x_test,x_train = pls.cv_predict(x, y, <span class="number">10</span>)</span><br><span class="line">    <span class="built_in">print</span>(y_pre)</span><br><span class="line">    RMSEcv, min_RMSEcv, best_comp = pls.RMSE_CV(y_pre, cv.y, cv)</span><br><span class="line">    <span class="built_in">print</span>(RMSEcv)</span><br><span class="line">    pls.show_Select_comp(RMSEcv)</span><br><span class="line"></span><br><span class="line">    pls.show_cv_predict(y,x_test,y_test,y_train,x_train,pls1)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line"><span class="comment"># from sklearn.decomposition import PCA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cross_Validation</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y, n_folds, max_components</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.n_folds = n_folds</span><br><span class="line">        self.max_components = max_components</span><br><span class="line">        self.n = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">CV</span>(<span class="params">self</span>):</span><br><span class="line">        kf = cross_validation.KFold(self.n, self.n_folds)</span><br><span class="line">        x_train=[]</span><br><span class="line">        x_test=[]</span><br><span class="line">        y_train=[]</span><br><span class="line">        y_test=[]</span><br><span class="line">        <span class="keyword">for</span> train_index,test_index <span class="keyword">in</span> kf:</span><br><span class="line">            xtr, xte = self.x[train_index], self.x[test_index]</span><br><span class="line">            ytr, yte = self.y[train_index], self.y[test_index]</span><br><span class="line">            x_train.append(xtr)</span><br><span class="line">            x_test.append(xte)</span><br><span class="line">            y_train.append(ytr)</span><br><span class="line">            y_test.append(yte)</span><br><span class="line">        <span class="keyword">return</span> x_train, x_test, y_train, y_test</span><br></pre></td></tr></table></figure><p>预测结果：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204193337549.png"alt="image-20230204193337549" /><figcaption aria-hidden="true">image-20230204193337549</figcaption></figure><p>参数选择：<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204193345363.png"alt="image-20230204193345363" /></p><p>拟合效果：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204193435252.png"alt="image-20230204193435252" /><figcaption aria-hidden="true">image-20230204193435252</figcaption></figure><h2 id="总结-6">总结</h2><p>PLS的代码实现总体上和PCR类似，其核心区别就在于PLS的fit和predict函数发生了改变，</p><h1 id="实验七-岭回归">实验七 岭回归</h1><h2 id="实验目的-7">实验目的</h2><ol type="1"><li>实现RR算法</li><li>掌握交叉验证算法应用；</li><li>观察岭脊</li></ol><h2 id="实验场地与设备-7">实验场地与设备</h2><p>实验室4074</p><h2 id="实验方式-7">实验方式</h2><p>程序设计</p><h2 id="实验设计-7">实验设计</h2><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204194615350.png" alt="image-20230204194615350" style="zoom:50%;" /></p><h2 id="实验内容-7">实验内容</h2><h3 id="岭迹">岭迹</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> linear_model</span><br><span class="line"></span><br><span class="line"><span class="comment"># X is the 10x10 Hilbert matrix</span></span><br><span class="line">X = <span class="number">1.0</span> / (np.arange(<span class="number">1</span>, <span class="number">11</span>) + np.arange(<span class="number">0</span>, <span class="number">10</span>)[:, np.newaxis])</span><br><span class="line">y = np.ones(<span class="number">10</span>)</span><br><span class="line"></span><br><span class="line">n_alphas = <span class="number">200</span></span><br><span class="line">alphas = np.logspace(-<span class="number">10</span>, -<span class="number">2</span>, n_alphas)</span><br><span class="line"></span><br><span class="line">coefs = []</span><br><span class="line"><span class="keyword">for</span> a <span class="keyword">in</span> alphas:</span><br><span class="line">    ridge = linear_model.Ridge(alpha=a, fit_intercept=<span class="literal">False</span>)</span><br><span class="line">    ridge.fit(X, y)</span><br><span class="line">    coefs.append(ridge.coef_)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(alphas)</span><br><span class="line">ax = plt.gca()</span><br><span class="line"></span><br><span class="line">ax.plot(alphas, coefs)</span><br><span class="line"><span class="comment"># ax.set_xscale(&quot;log&quot;)</span></span><br><span class="line"><span class="comment"># ax.set_xlim(ax.get_xlim()[::-1])  # reverse axis</span></span><br><span class="line">plt.xlabel(<span class="string">&quot;alpha&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;weights&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Ridge coefficients as a function of the regularization&quot;</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;tight&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>算术坐标尺度<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204193803654.png"alt="image-20230204193803654" /></p><p>对数坐标尺度<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204193817727.png"alt="image-20230204193817727" /></p><h3 id="rr实现">RR实现</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> scipy.io <span class="keyword">as</span> sio</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> Ridge</span><br><span class="line"><span class="keyword">from</span> Cross_Validation <span class="keyword">import</span> Cross_Validation</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RidgeRegression</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n_lambda</span>):</span><br><span class="line">        self.n_lambda=n_lambda</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,y,best_lambda</span>):</span><br><span class="line">        c=np.dot(X.T,X)</span><br><span class="line">        I=np.eye(np.shape(c)[<span class="number">0</span>])</span><br><span class="line">        d=np.dot(best_lambda,I)</span><br><span class="line">        e=(c+d)</span><br><span class="line">        e=np.linalg.inv(e)</span><br><span class="line">        b = np.dot(X.T, y)</span><br><span class="line">        b=np.dot(e,b)</span><br><span class="line">        self.b=b</span><br><span class="line">        <span class="keyword">return</span> b</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">pridict</span>(<span class="params">self,x</span>):</span><br><span class="line">        y_pri=np.dot(x,self.b)</span><br><span class="line">        <span class="keyword">return</span> y_pri</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cv_pridict</span>(<span class="params">self,X,y,n_fold</span>):</span><br><span class="line">        cv = Cross_Validation(X, y, n_fold, self.n_lambda)</span><br><span class="line">        X_train, X_test, y_train, y_test = cv.CV()</span><br><span class="line">        y_allPredict = np.ones((<span class="number">1</span>, self.n_lambda))</span><br><span class="line">        lambda1=np.logspace(-<span class="number">10</span>,-<span class="number">2</span>,self.n_lambda)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_fold):</span><br><span class="line">            y_predict = np.zeros((y_test[i].shape[<span class="number">0</span>], self.n_lambda))</span><br><span class="line">            k=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j  <span class="keyword">in</span> np.nditer(lambda1) :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>,k+<span class="number">1</span>+self.n_lambda*i,<span class="string">&#x27;次:&#x27;</span>,j)</span><br><span class="line">                pls = self.fit(X_train[i], y_train[i], j)</span><br><span class="line">                y_pre = self.pridict(X_test[i])</span><br><span class="line">                y_predict[:, k] = y_pre.ravel()</span><br><span class="line">                k=k+<span class="number">1</span></span><br><span class="line">            y_allPredict = np.vstack((y_allPredict, y_predict))</span><br><span class="line">        y_allPredict = y_allPredict[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> y_allPredict, cv, y_test, y_train, X_test, X_train</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">RMSE_CV</span>(<span class="params">self, y_allPredict, y_measure, cv</span>):</span><br><span class="line">        press = np.square(np.subtract(y_allPredict, y_measure))</span><br><span class="line">        press_all = np.<span class="built_in">sum</span>(press, axis=<span class="number">0</span>)</span><br><span class="line">        RMSECV = np.sqrt(press_all / cv.n)</span><br><span class="line">        lambda_best= <span class="built_in">min</span>(RMSECV)</span><br><span class="line">        <span class="keyword">return</span> RMSECV, lambda_best</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_Select_lambda</span>(<span class="params">self,RMSECV</span>):</span><br><span class="line">        x=np.logspace(-<span class="number">10</span>,-<span class="number">2</span>,self.n_lambda)</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot(x,RMSECV,marker=<span class="string">&#x27;^&#x27;</span>,markersize=<span class="number">10</span>,markerfacecolor=<span class="string">&#x27;orange&#x27;</span>,color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;lambda&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;RMSECV&#x27;</span>)</span><br><span class="line">        ax = plt.gca()</span><br><span class="line">        ax.set_xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">        ax.set_xlim(ax.get_xlim()[::-<span class="number">1</span>])</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_cv_predict</span>(<span class="params">self, y, x_test, y_test, y_train, x_train</span>):</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot([<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], [<span class="built_in">min</span>(y), <span class="built_in">max</span>(y)], label=<span class="string">&#x27;y=x&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        plt.scatter(y_test[<span class="number">0</span>], self.pridict(x_test[<span class="number">0</span>]), color=<span class="string">&#x27;red&#x27;</span>, label=<span class="string">&#x27;test set&#x27;</span>)</span><br><span class="line">        plt.scatter(y_train[<span class="number">0</span>], self.pridict(x_train[<span class="number">0</span>]), color=<span class="string">&#x27;blue&#x27;</span>, label=<span class="string">&#x27;train set&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;measure value&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;predict value&#x27;</span>)</span><br><span class="line">        plt.legend()</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ ==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data = sio.loadmat(<span class="string">&quot;../NIRcorn.mat&quot;</span>)</span><br><span class="line"></span><br><span class="line">    cornprop = data[<span class="string">&quot;cornprop&quot;</span>]</span><br><span class="line">    m5spec = data[<span class="string">&#x27;m5spec&#x27;</span>][<span class="string">&#x27;data&#x27;</span>][<span class="number">0</span>][<span class="number">0</span>]</span><br><span class="line">    y = data[<span class="string">&#x27;cornprop&#x27;</span>][:, [<span class="number">0</span>]]</span><br><span class="line">    x = m5spec</span><br><span class="line"></span><br><span class="line">    rr=RidgeRegression(<span class="number">50</span>)</span><br><span class="line">    rr.fit(x,y,<span class="number">0.335641904424</span>)</span><br><span class="line">    y_pri=rr.pridict(x)</span><br><span class="line"></span><br><span class="line">    y_allPredict, cv, y_test, y_train, X_test, X_train=rr.cv_pridict(x,y,<span class="number">20</span>)</span><br><span class="line">    RMSECV, best_lambda =rr.RMSE_CV(y_allPredict,cv.y,cv)</span><br><span class="line">    rr.show_Select_lambda(RMSECV)</span><br><span class="line">    <span class="built_in">print</span>(best_lambda)</span><br><span class="line"></span><br><span class="line">    rr.show_cv_predict(y, X_test, y_test, y_train, X_train)</span><br><span class="line">    <span class="built_in">print</span>(y_train[<span class="number">0</span>])</span><br><span class="line">    <span class="built_in">print</span>(rr.pridict(X_train[<span class="number">0</span>]))</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> cross_validation</span><br><span class="line"><span class="comment"># from sklearn.decomposition import PCA</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cross_Validation</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y, n_folds, max_lambda</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line">        self.n_folds = n_folds</span><br><span class="line">        self.n = x.shape[<span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">CV</span>(<span class="params">self</span>):</span><br><span class="line">        kf = cross_validation.KFold(self.n, self.n_folds)</span><br><span class="line">        x_train=[]</span><br><span class="line">        x_test=[]</span><br><span class="line">        y_train=[]</span><br><span class="line">        y_test=[]</span><br><span class="line">        <span class="keyword">for</span> train_index,test_index <span class="keyword">in</span> kf:</span><br><span class="line">            xtr, xte = self.x[train_index], self.x[test_index]</span><br><span class="line">            ytr, yte = self.y[train_index], self.y[test_index]</span><br><span class="line">            x_train.append(xtr)</span><br><span class="line">            x_test.append(xte)</span><br><span class="line">            y_train.append(ytr)</span><br><span class="line">            y_test.append(yte)</span><br><span class="line">        <span class="keyword">return</span> x_train, x_test, y_train, y_test</span><br></pre></td></tr></table></figure><p>正则化参数选择图像<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204194028992.png"alt="image-20230204194028992" /></p><p>拟合效果图像</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230204194101069.png"alt="image-20230204194101069" /><figcaption aria-hidden="true">image-20230204194101069</figcaption></figure><p>可以发现最后回归系数都分布在10左右，比较平均，有很强的抗扰动。</p><h2 id="总结-7">总结</h2><p>岭回归对于模型的特征控制有着很好的效果，形成的回归系数相对平均有很强的抗干扰左右，而且能解决多重共线性，解决布满秩的情况。有很强的应用价值。</p>]]></content>
      
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习作业</title>
      <link href="/2023/04/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%9C%E4%B8%9A/"/>
      <url>/2023/04/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E4%BD%9C%E4%B8%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="作业九-反向传播算法bp">作业九 反向传播算法（BP）</h1><h2 id="算法推导">算法推导</h2><p><img src="G:\专业学习\第六学期\机器学习\神经网络.png" alt="神经网络" style="zoom: 25%;" /></p><p>令input layer 到hidden layer的权重为<spanclass="math inline">\(w_{ih}\)</span>，hidden layer和outputlayer的权重为<span class="math inline">\(w_{ho}\)</span></p><p>前向算法伪代码：</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>Algorithm1: forward</th></tr></thead><tbody><tr class="odd"><td>input: X</td></tr><tr class="even"><td>output: <span class="math inline">\(y\)</span></td></tr><tr class="odd"><td>1. hidden_in=<span class="math inline">\(w_{ih}X+b_1\)</span><br/>2. hidden_out=<spanclass="math inline">\(\sigma(hidden\_in)\)</span><br/>3. output_in=<spanclass="math inline">\(w_{ho}X+b_2\)</span><br/>4. output_out=<spanclass="math inline">\(\sigma(output\_out)\)</span>#根据情况可有可无，无的话则output_in即为output_out<br/>5.y=output_out<br />6.<br/>7. return <spanclass="math inline">\(y\)</span></td></tr></tbody></table><p>output的输出结果为：<spanclass="math inline">\(y_j\)</span>，目标结果为<spanclass="math inline">\(t_j\)</span></p><p>令误差函数为<spanclass="math inline">\(E=\frac{1}{2}\sum_{j=0}^{n}{(y_j-t_j)^2}\)</span>，其中<spanclass="math inline">\(i\)</span>为output layer的神经元个数</p><p>下面给出反向传播的伪代码：</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>Algorithm1: backprop</th></tr></thead><tbody><tr class="odd"><td>input: X,t,y,learn_rate</td></tr><tr class="even"><td>output: null</td></tr><tr class="odd"><td>1. <spanclass="math inline">\(\delta_1=(y-t)\sigma^{&#39;}(y)\)</span> #outputlayer的梯度<br />2. <spanclass="math inline">\(\delta_2=\sigma^{&#39;}(hidden\_output)\sum_{i=0}^{n}{w_{ho}\delta_1}\)</span>#求解hidden layer的梯度<br />3. <br/>4. <spanclass="math inline">\(w_{ih}-=learn\_rate*\delta_2\)</span><br/>5. <spanclass="math inline">\(w_{ho}-=learn\_rate*\delta_1\)</span><br/>6. <spanclass="math inline">\(b_{2}-=learn\_rate*\delta_2\)</span><br/>7. <spanclass="math inline">\(b_{1}-=learn\_rate*\delta_1\)</span><br/>8.<br/>9. return</td></tr></tbody></table><p>其中梯度求导原因如下： <span class="math display">\[\begin{array}{left}\frac{\partial E}{\partial w_{ij}}=\frac{\partial E}{\partiala{j}}\frac{\partial a_j}{\partial w_{ij}} \\其中：\\E=\frac{1}{2}\sum_{j=0}^{n}{(y_j-t_j)^2}\\a_j=\sum_i{w_{ij}z_i}\\z_j=\sigma(a_j)\\那么：\\\frac{\partial E}{\partial a{j}}=y_j-t_j \\\delta \equiv\frac{\partial E}{\partial a{j}}\\则：\\\frac{\partial E}{\partial w_{ij}}=\delta\frac{\partial a_j}{\partialw_{ij}}=\delta\sigma^{&#39;}(a_j)\end{array}\]</span></p><h2 id="拟合sin曲线">拟合sin曲线</h2><p>在实现中，outputlayer输出时不能采用Sigmoid函数激活，否则无法出现正常结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NN</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, input_neurons, hidden_neurons, output_neurons, learning_rate, epochs</span>):</span><br><span class="line">        self.input_neurons = input_neurons</span><br><span class="line">        self.hidden_neurons = hidden_neurons</span><br><span class="line">        self.output_neurons = output_neurons</span><br><span class="line">        self.epochs = epochs</span><br><span class="line">        self.lr = learning_rate</span><br><span class="line"></span><br><span class="line">        self.wih = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (self.hidden_neurons, self.input_neurons))</span><br><span class="line">        self.bih = <span class="number">0</span></span><br><span class="line">        self.who = np.random.normal(<span class="number">0</span>, <span class="number">1</span>, (self.output_neurons, self.hidden_neurons))</span><br><span class="line">        self.bho = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">activation</span>(<span class="params">self, Z</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (<span class="number">1</span> + np.exp(-Z))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">sigmoid_derivative</span>(<span class="params">self, Z</span>):</span><br><span class="line">        <span class="keyword">return</span> self.activation(Z) * (<span class="number">1</span> - self.activation(Z))</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 前向传播</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">forward</span>(<span class="params">self, input_list</span>):</span><br><span class="line">        inputs = np.array(input_list, ndmin=<span class="number">2</span>)</span><br><span class="line">        hidden_inputs = np.dot(self.wih, inputs) + self.bih</span><br><span class="line">        hidden_outputs = self.activation(hidden_inputs)</span><br><span class="line">        final_inputs = np.dot(self.who, hidden_outputs) + self.bho</span><br><span class="line">        final_outputs=final_inputs</span><br><span class="line">        <span class="keyword">return</span> final_outputs</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 反向传播</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">backprop</span>(<span class="params">self, inputs_list, targets_list</span>):</span><br><span class="line">        inputs = np.array(inputs_list, ndmin=<span class="number">2</span>)</span><br><span class="line">        tj = np.array(targets_list, ndmin=<span class="number">2</span>)</span><br><span class="line">        hidden_inputs = np.dot(self.wih, inputs) + self.bih</span><br><span class="line">        hidden_outputs = self.activation(hidden_inputs)</span><br><span class="line">        final_inputs = np.dot(self.who, hidden_outputs) + self.bho</span><br><span class="line">        yj = final_inputs</span><br><span class="line">        output_errors = (yj - tj)</span><br><span class="line">        hidden_errors = np.dot(self.who.T, output_errors)*self.sigmoid_derivative(hidden_outputs)</span><br><span class="line">        self.who -= self.lr * np.dot(output_errors , np.transpose(hidden_outputs))</span><br><span class="line">        self.wih -= self.lr * np.dot(hidden_errors, np.transpose(inputs))</span><br><span class="line"></span><br><span class="line">        <span class="comment"># updating bias</span></span><br><span class="line">        self.bho -= self.lr * output_errors</span><br><span class="line">        self.bih -= self.lr * hidden_errors</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, inputs_list, targets_list</span>):</span><br><span class="line">        loss_list=[]</span><br><span class="line">        <span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(self.epochs):</span><br><span class="line">            self.backprop(inputs_list, targets_list)</span><br><span class="line">            y_pre=self.predict(inputs_list)</span><br><span class="line">            loss=np.sqrt(np.<span class="built_in">sum</span>(np.square(y_pre-targets_list)))/<span class="number">2</span></span><br><span class="line">            loss_list.append(loss)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">f&quot;Epoch <span class="subst">&#123;epoch&#125;</span>/<span class="subst">&#123;self.epochs&#125;</span> ,loss:<span class="subst">&#123;loss&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> loss_list</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self, X</span>):</span><br><span class="line">        outputs = self.forward(X).T</span><br><span class="line">        <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line"></span><br><span class="line">    plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line">    <span class="comment"># 创建数据</span></span><br><span class="line">    x = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    y = np.sin(<span class="number">2</span> * np.pi * x)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 添加随机噪声</span></span><br><span class="line">    np.random.seed(<span class="number">20</span>)</span><br><span class="line">    y_noisy = y + <span class="number">0.05</span> * np.random.normal(size=x.shape)</span><br><span class="line">    nn = NN(<span class="number">1</span>, <span class="number">50</span>, <span class="number">1</span>, <span class="number">0.02</span>,<span class="number">200</span>)</span><br><span class="line">    loss=nn.fit(x, y_noisy)</span><br><span class="line"></span><br><span class="line">    x_test = np.linspace(<span class="number">0</span>, <span class="number">1</span>, <span class="number">100</span>)</span><br><span class="line">    y_pred = nn.predict(x_test)</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(x_test, y_pred, label=<span class="string">&#x27;Regressor&#x27;</span>, color=<span class="string">&#x27;#FFA628&#x27;</span>)</span><br><span class="line">    plt.plot(x, y, label=<span class="string">&#x27;True function&#x27;</span>, color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">    plt.scatter(x, y_noisy, edgecolor=<span class="string">&#x27;b&#x27;</span>, s=<span class="number">20</span>, label=<span class="string">&#x27;Noisy samples&#x27;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(np.linspace(<span class="number">3</span>,<span class="built_in">len</span>(loss),<span class="built_in">len</span>(loss)-<span class="number">3</span>),loss[<span class="number">3</span>:])</span><br><span class="line">    plt.title(<span class="string">&#x27;loss curve&#x27;</span>)</span><br><span class="line">    plt.tight_layout()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p>经过200次迭代后，结果如下：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230507143232977.png" alt="image-20230507143232977" style="zoom:50%;" /></p><p>loss曲线如下：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230507143309196.png" alt="image-20230507143309196" style="zoom:50%;" /></p><p>如果迭代2000次：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/f624b4755450bca033368ecadb12ed7.png" alt="f624b4755450bca033368ecadb12ed7" style="zoom: 67%;" /></p><p>可以看到有明显过拟合。</p><p>如果输出结果，采用Sigmoid函数处理：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230507143624375.png" alt="image-20230507143624375" style="zoom: 50%;" /></p><p>原因很简单，因为Sigmoid函数将数值缩放到了0，导致结果均为0，如果将误差符号反向，那么将得到一条y=1的直线作业八神经网络初步</p><h1 id="作业八-神经网络初步">作业八 神经网络初步</h1><p>sklearn中人工神经网络（ANN）主要提供的是多层感知机（MLP），其中有回归和分类两种，回归感知机还有能够自动实现交叉验证的版本。</p><h2 id="mlpclassifier二分类">MLPClassifier二分类</h2><p>流程如下：</p><ol type="1"><li>导入iris数据，取后两类</li><li>标准化</li><li>PCA得到x_pca，y</li><li>初始化MLP，训练</li><li>绘制分类面</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> l1_min_c</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_decision_surface</span>(<span class="params">model, X, y, grid_size=<span class="number">0.02</span></span>):</span><br><span class="line">    <span class="comment"># 获取数据范围</span></span><br><span class="line">    x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">0.5</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">0.5</span></span><br><span class="line">    y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">0.5</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成网格点</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, grid_size), np.arange(y_min, y_max, grid_size))</span><br><span class="line">    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制分类面和训练数据</span></span><br><span class="line">    cmap_light = ListedColormap([<span class="string">&#x27;#FFAAAA&#x27;</span>, <span class="string">&#x27;#AAFFAA&#x27;</span>, <span class="string">&#x27;#AAAAFF&#x27;</span>])</span><br><span class="line">    cmap_bold = ListedColormap([<span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#00FF00&#x27;</span>, <span class="string">&#x27;#0000FF&#x27;</span>])</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.pcolormesh(xx, yy, Z, cmap=cmap_light)</span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=cmap_bold, edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    plt.xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">    plt.ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Sepal length&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Sepal width&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Iris classification using MLP&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line">X = X[y != <span class="number">0</span>]</span><br><span class="line">y = y[y != <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">standard=StandardScaler()</span><br><span class="line">X=standard.fit_transform(X)</span><br><span class="line"><span class="comment"># PCA</span></span><br><span class="line">pca=PCA(n_components=<span class="number">2</span>)</span><br><span class="line">x_pca=pca.fit_transform(X)</span><br><span class="line"><span class="comment"># 初始化mlp</span></span><br><span class="line">mlp=MLPClassifier(solver=<span class="string">&#x27;lbfgs&#x27;</span>,hidden_layer_sizes=(<span class="number">5</span>,<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">mlp.fit(x_pca,y)</span><br><span class="line"></span><br><span class="line">plot_decision_surface(mlp, x_pca, y)</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230422220300024.png" alt="image-20230422220300024" style="zoom:50%;" /></p><h2 id="mlpclassifier多分类">MLPClassifier多分类</h2><p>流程如下：</p><ol type="1"><li>导入iris数据</li><li>标准化</li><li>PCA得到x_pca，y</li><li>初始化MLP，训练</li><li>绘制分类面</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris</span><br><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPClassifier</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.metrics <span class="keyword">import</span> plot_confusion_matrix</span><br><span class="line"><span class="keyword">from</span> matplotlib.colors <span class="keyword">import</span> ListedColormap</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_decision_surface</span>(<span class="params">model, X, y, grid_size=<span class="number">0.02</span></span>):</span><br><span class="line">    <span class="comment"># 获取数据范围</span></span><br><span class="line">    x_min, x_max = X[:, <span class="number">0</span>].<span class="built_in">min</span>() - <span class="number">0.5</span>, X[:, <span class="number">0</span>].<span class="built_in">max</span>() + <span class="number">0.5</span></span><br><span class="line">    y_min, y_max = X[:, <span class="number">1</span>].<span class="built_in">min</span>() - <span class="number">0.5</span>, X[:, <span class="number">1</span>].<span class="built_in">max</span>() + <span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成网格点</span></span><br><span class="line">    xx, yy = np.meshgrid(np.arange(x_min, x_max, grid_size), np.arange(y_min, y_max, grid_size))</span><br><span class="line">    Z = model.predict(np.c_[xx.ravel(), yy.ravel()])</span><br><span class="line">    Z = Z.reshape(xx.shape)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制分类面和训练数据</span></span><br><span class="line">    cmap_light = ListedColormap([<span class="string">&#x27;#FFAAAA&#x27;</span>, <span class="string">&#x27;#AAFFAA&#x27;</span>, <span class="string">&#x27;#AAAAFF&#x27;</span>])</span><br><span class="line">    cmap_bold = ListedColormap([<span class="string">&#x27;#FF0000&#x27;</span>, <span class="string">&#x27;#00FF00&#x27;</span>, <span class="string">&#x27;#0000FF&#x27;</span>])</span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.pcolormesh(xx, yy, Z, cmap=cmap_light)</span><br><span class="line">    plt.scatter(X[:, <span class="number">0</span>], X[:, <span class="number">1</span>], c=y, cmap=cmap_bold, edgecolor=<span class="string">&#x27;k&#x27;</span>)</span><br><span class="line">    plt.xlim(xx.<span class="built_in">min</span>(), xx.<span class="built_in">max</span>())</span><br><span class="line">    plt.ylim(yy.<span class="built_in">min</span>(), yy.<span class="built_in">max</span>())</span><br><span class="line">    plt.xlabel(<span class="string">&#x27;Sepal length&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;Sepal width&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">&#x27;Iris classification using MLP&#x27;</span>)</span><br><span class="line">    plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 加载数据</span></span><br><span class="line">iris = load_iris()</span><br><span class="line">X = iris.data[:, :<span class="number">2</span>]  <span class="comment"># 只使用前两个特征</span></span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># 划分数据集</span></span><br><span class="line">X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=<span class="number">0.3</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多层感知器模型</span></span><br><span class="line">mlp = MLPClassifier(hidden_layer_sizes=(<span class="number">10</span>,), max_iter=<span class="number">1000</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">mlp.fit(X_train, y_train)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 绘制分类面</span></span><br><span class="line">plot_decision_surface(mlp, X_train, y_train)</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230422220443459.png" alt="image-20230422220443459" style="zoom:50%;" /></p><h2 id="mlpregressor">MLPRegressor</h2><p>程序流程如下：</p><ol type="1"><li>创建数据X，y</li><li>为y添加随机噪声</li><li>初始化MLP</li><li>训练MLP</li><li>绘制预测效果图</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.neural_network <span class="keyword">import</span> MLPRegressor</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line"><span class="comment"># 创建数据</span></span><br><span class="line">x = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加随机噪声</span></span><br><span class="line">np.random.seed(<span class="number">42</span>)</span><br><span class="line">y_noisy = y + <span class="number">0.2</span> * np.random.normal(size=x.shape)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建多层感知器模型</span></span><br><span class="line">mlp = MLPRegressor(hidden_layer_sizes=(<span class="number">50</span>,), max_iter=<span class="number">1000</span>, random_state=<span class="number">42</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练模型</span></span><br><span class="line">mlp.fit(x.reshape(-<span class="number">1</span>, <span class="number">1</span>), y_noisy)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 预测并绘制结果</span></span><br><span class="line">x_test = np.linspace(-<span class="number">5.5</span>, <span class="number">5.5</span>, <span class="number">100</span>)</span><br><span class="line">y_pred = mlp.predict(x_test.reshape(-<span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">plt.plot(x_test, y_pred, label=<span class="string">&#x27;MLP Regressor&#x27;</span>,color=<span class="string">&#x27;#FFA628&#x27;</span>)</span><br><span class="line">plt.plot(x, y, label=<span class="string">&#x27;True function&#x27;</span>,color=<span class="string">&#x27;g&#x27;</span>)</span><br><span class="line">plt.scatter(x, y_noisy, edgecolor=<span class="string">&#x27;b&#x27;</span>, s=<span class="number">20</span>, label=<span class="string">&#x27;Noisy samples&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.title(<span class="string">&#x27;MLP Regressor&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230422220624823.png" alt="image-20230422220624823" style="zoom:50%;" /></p><h1 id="作业七-逻辑回归分类">作业七 逻辑回归分类</h1><p>由于都是从sklearn中调用，并不涉及什么复杂算法，因此下面采用列表的方式描述程序作用</p><h2 id="二分类逻辑回归">二分类逻辑回归</h2><p>首先说明下面程序的目的：</p><table><thead><tr class="header"><th>1.观察不同惩罚项系数对应参数变化</th></tr></thead><tbody><tr class="odd"><td><strong>2.观察不同惩罚项系数对应错误率</strong></td></tr><tr class="even"><td><strong>3.可视化二分类结果</strong></td></tr></tbody></table><p>流程如下：</p><ol type="1"><li>导入iris数据，取后两类</li><li>标准化</li><li>PCA得到x_pca，y</li><li>初始化逻辑回归</li><li>调整参数c，分别训练逻辑回归得到权重参数和错误率</li><li>绘制错误率和权重参数曲线</li><li>绘制分类面</li></ol><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> l1_min_c</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"><span class="comment"># 选出前两类</span></span><br><span class="line">X = X[y != <span class="number">0</span>]</span><br><span class="line">y = y[y != <span class="number">0</span>]</span><br><span class="line"><span class="comment"># 画出图像</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X[y == <span class="number">2</span>, <span class="number">0</span>], X[y == <span class="number">2</span>, <span class="number">1</span>], color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">plt.scatter(X[y == <span class="number">1</span>, <span class="number">0</span>], X[y == <span class="number">1</span>, <span class="number">1</span>], color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 训练</span></span><br><span class="line">cs = l1_min_c(X, y, loss=<span class="string">&#x27;log&#x27;</span>) * np.logspace(<span class="number">0</span>, <span class="number">7</span>, <span class="number">16</span>)</span><br><span class="line"><span class="comment"># 初始化逻辑回归</span></span><br><span class="line">clf = LogisticRegression(</span><br><span class="line">    penalty=<span class="string">&#x27;l1&#x27;</span>,</span><br><span class="line">    solver=<span class="string">&#x27;liblinear&#x27;</span>,</span><br><span class="line">    tol=<span class="number">1e-6</span>,</span><br><span class="line">    max_iter=<span class="built_in">int</span>(<span class="number">1e6</span>),</span><br><span class="line">    warm_start=<span class="literal">True</span>,</span><br><span class="line">    intercept_scaling=<span class="number">1000.0</span>,</span><br><span class="line">)</span><br><span class="line"><span class="comment"># 错误率</span></span><br><span class="line">errors = []</span><br><span class="line"><span class="comment"># 各个特征对参数</span></span><br><span class="line">coefs_ = []</span><br><span class="line"><span class="comment"># 拟合观察参数</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> cs:</span><br><span class="line">    clf.set_params(C=c)</span><br><span class="line">    clf.fit(X, y)</span><br><span class="line">    y_pre = clf.predict(X)</span><br><span class="line">    error = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(y)):</span><br><span class="line">        <span class="keyword">if</span> y_pre[i] != y[i]:</span><br><span class="line">            error = error + <span class="number">1</span></span><br><span class="line">    errors.append(error)</span><br><span class="line">    coefs_.append(clf.coef_.ravel().copy())</span><br><span class="line">errors = np.array(errors) / <span class="built_in">len</span>(y)</span><br><span class="line">coefs_ = np.array(coefs_)</span><br><span class="line"><span class="comment"># 绘制参数变化</span></span><br><span class="line">plt.plot(np.log10(cs), coefs_, marker=<span class="string">&quot;o&quot;</span>)</span><br><span class="line">ymin, ymax = plt.ylim()</span><br><span class="line">plt.xlabel(<span class="string">&quot;log(C)&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;Coefficients&quot;</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Logistic Regression Path&quot;</span>)</span><br><span class="line">plt.axis(<span class="string">&quot;tight&quot;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 绘制错误率</span></span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.log10(cs), errors, marker=<span class="string">&#x27;^&#x27;</span>, color=<span class="string">&#x27;orange&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;error rate&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;log(C)&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"><span class="comment"># 最优拟合</span></span><br><span class="line">clf.set_params(C=<span class="number">1</span>)</span><br><span class="line">clf.fit(X, y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># PCA可视化</span></span><br><span class="line">pca = PCA(n_components=<span class="number">2</span>)</span><br><span class="line">X1 = pca.fit_transform(X)</span><br><span class="line">clf.set_params(C=<span class="number">1</span>)</span><br><span class="line">clf.fit(X1, y)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X1[y == <span class="number">2</span>, <span class="number">0</span>], X1[y == <span class="number">2</span>, <span class="number">1</span>], color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">plt.scatter(X1[y == <span class="number">1</span>, <span class="number">0</span>], X1[y == <span class="number">1</span>, <span class="number">1</span>], color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">plt.plot([<span class="built_in">min</span>(X1[:, <span class="number">0</span>]), <span class="built_in">max</span>(X1[:, <span class="number">0</span>])], [-(<span class="built_in">min</span>(X1[:, <span class="number">0</span>]) * clf.coef_[<span class="number">0</span>, <span class="number">0</span>] + clf.intercept_[<span class="number">0</span>]) / clf.coef_[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                                          -(<span class="built_in">max</span>(X1[:, <span class="number">0</span>]) * clf.coef_[<span class="number">0</span>, <span class="number">0</span>] + clf.intercept_[<span class="number">0</span>]) / clf.coef_[<span class="number">0</span>, <span class="number">1</span>]],</span><br><span class="line">         label=<span class="string">&#x27;classier&#x27;</span>, linewidth=<span class="number">3.0</span>, color=<span class="string">&#x27;black&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;component 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;component 2&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>结果如下：</p><p>不同惩罚项对应的参数变化，可以看出当惩罚项小于1时，对于模型的稀疏化效果较好。</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230422214826267.png" alt="image-20230422214826267" style="zoom:50%;" /></p><p>不同惩罚项系数对应的分类错误率，选择为10时效果较好；</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230422214946938.png" alt="image-20230422214946938" style="zoom:50%;" /></p><p>分类结果效果如图：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230422215101050.png" alt="image-20230422215101050" style="zoom:50%;" /></p><h2 id="多分类逻辑回归">多分类逻辑回归</h2><p>首先说明下面程序的目的：</p><table><thead><tr class="header"><th>1.绘制多分类的分类面</th></tr></thead><tbody></tbody></table><p>流程如下：</p><ol type="1"><li>导入iris数据</li><li>标准化</li><li>PCA得到x_pca，y</li><li>初始化逻辑回归，训练逻辑回归</li><li>绘制分类面</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sklearn <span class="keyword">import</span> datasets</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LogisticRegression</span><br><span class="line"><span class="keyword">from</span> sklearn.svm <span class="keyword">import</span> l1_min_c</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.decomposition <span class="keyword">import</span> PCA</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> StandardScaler</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line"></span><br><span class="line">iris = datasets.load_iris()</span><br><span class="line">X = iris.data</span><br><span class="line">y = iris.target</span><br><span class="line"><span class="comment"># 标准化</span></span><br><span class="line">standard=StandardScaler()</span><br><span class="line">X=standard.fit_transform(X)</span><br><span class="line"><span class="comment"># PCA</span></span><br><span class="line">pca=PCA(n_components=<span class="number">2</span>)</span><br><span class="line">x_pca=pca.fit_transform(X)</span><br><span class="line"><span class="comment"># 初始化逻辑回归</span></span><br><span class="line">clf = LogisticRegression(</span><br><span class="line">    solver=<span class="string">&#x27;liblinear&#x27;</span>,</span><br><span class="line">    max_iter=<span class="built_in">int</span>(<span class="number">1e6</span>),</span><br><span class="line">    warm_start=<span class="literal">True</span>,</span><br><span class="line">    intercept_scaling=<span class="number">1000.0</span></span><br><span class="line">)</span><br><span class="line">clf.fit(x_pca,y)</span><br><span class="line">coef,intercept=np.array(clf.coef_),np.array(clf.intercept_)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(x_pca[y == <span class="number">2</span>, <span class="number">0</span>], x_pca[y == <span class="number">2</span>, <span class="number">1</span>], color=<span class="string">&#x27;r&#x27;</span>, label=<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">plt.scatter(x_pca[y == <span class="number">1</span>, <span class="number">0</span>], x_pca[y == <span class="number">1</span>, <span class="number">1</span>], color=<span class="string">&#x27;g&#x27;</span>, label=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">plt.scatter(x_pca[y == <span class="number">0</span>, <span class="number">0</span>], x_pca[y == <span class="number">0</span>, <span class="number">1</span>], color=<span class="string">&#x27;b&#x27;</span>, label=<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">plt.plot([<span class="built_in">min</span>(x_pca[:, <span class="number">0</span>]), <span class="built_in">max</span>(x_pca[:, <span class="number">0</span>])], [-(<span class="built_in">min</span>(x_pca[:, <span class="number">0</span>]) * coef[<span class="number">0</span>, <span class="number">0</span>] + intercept[<span class="number">0</span>]) / coef[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">                                          -(<span class="built_in">max</span>(x_pca[:, <span class="number">0</span>]) * coef[<span class="number">0</span>, <span class="number">0</span>] + intercept[<span class="number">0</span>]) / coef[<span class="number">0</span>, <span class="number">1</span>]],</span><br><span class="line">         label=<span class="string">&#x27;classier&#x27;</span>, linewidth=<span class="number">3.0</span>, color=<span class="string">&#x27;black&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line"></span><br><span class="line">plt.plot([<span class="built_in">min</span>(x_pca[:, <span class="number">0</span>]), <span class="built_in">max</span>(x_pca[:, <span class="number">0</span>])], [-(<span class="built_in">min</span>(x_pca[:, <span class="number">0</span>]) * coef[<span class="number">1</span>, <span class="number">0</span>] + intercept[<span class="number">1</span>]) / coef[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">                                          -(<span class="built_in">max</span>(x_pca[:, <span class="number">0</span>]) * coef[<span class="number">1</span>, <span class="number">0</span>] + intercept[<span class="number">1</span>]) / coef[<span class="number">1</span>, <span class="number">1</span>]],</span><br><span class="line">         label=<span class="string">&#x27;classier&#x27;</span>, linewidth=<span class="number">3.0</span>, color=<span class="string">&#x27;black&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.plot([<span class="built_in">min</span>(x_pca[:, <span class="number">0</span>]), <span class="built_in">max</span>(x_pca[:, <span class="number">0</span>])], [-(<span class="built_in">min</span>(x_pca[:, <span class="number">0</span>]) * coef[<span class="number">2</span>, <span class="number">0</span>] + intercept[<span class="number">2</span>]) / coef[<span class="number">2</span>, <span class="number">1</span>],</span><br><span class="line">                                          -(<span class="built_in">max</span>(x_pca[:, <span class="number">0</span>]) * coef[<span class="number">2</span>, <span class="number">0</span>] + intercept[<span class="number">2</span>]) / coef[<span class="number">2</span>, <span class="number">1</span>]],</span><br><span class="line">         label=<span class="string">&#x27;classier&#x27;</span>, linewidth=<span class="number">3.0</span>, color=<span class="string">&#x27;black&#x27;</span>, linestyle=<span class="string">&#x27;--&#x27;</span>)</span><br><span class="line">plt.ylim(-<span class="number">5</span>,<span class="number">5</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.xlabel(<span class="string">&#x27;component 1&#x27;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;component 2&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230422215323041.png" alt="image-20230422215323041" style="zoom:50%;" /></p><h1 id="作业六">作业六</h1><h2 id="bayesian-linear-regression">Bayesian Linear Regression</h2><p>所有算法都放在同一个Python文件下，函数算法伪代码如下：</p><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>Algorithm1: fit</th></tr></thead><tbody><tr class="odd"><td>input: X,t,degree, <spanclass="math inline">\(\alpha,\beta,\phi\)</span></td></tr><tr class="even"><td>output: <span class="math inline">\(m_n,S_n\)</span></td></tr><tr class="odd"><td>1. <strong><span class="math inline">\(if\)</span></strong>len(X.shape) == 1: # 预先判断形状<br /> 2. X=X.reshape(-1,1)<br />3.<strong><span class="math inline">\(if\)</span></strong> len(t.shape)==1:<br />4. t=t.reshape(-1,1)<br />5. <spanclass="math inline">\(S_n^{-1}=\alpha I+\beta\phi(X)^T\phi(X)\)</span> #计算协方差的逆<br />6. <spanclass="math inline">\(S_n=\)</span>np.linalg.inv(<spanclass="math inline">\(S_n^{-1}\)</span>)<br />7. <spanclass="math inline">\(m_n=\beta S_n \phi(X)^Tt\)</span> # 计算均值<br />8.<br />9. return <spanclass="math inline">\(m_n,S_n\)</span></td></tr></tbody></table><table><colgroup><col style="width: 100%" /></colgroup><thead><tr class="header"><th>Algorithm2: predict</th></tr></thead><tbody><tr class="odd"><td>input: X, <span class="math inline">\(\phi,m_n,S_n\)</span></td></tr><tr class="even"><td>output: <span class="math inline">\(mean,\sigma^2\)</span></td></tr><tr class="odd"><td>1. <span class="math inline">\(\sigma^2\)</span> = <spanclass="math inline">\(\frac{1}{\beta}+\phi(X)S_n\phi(X)^T\)</span><br />2.mean=<span class="math inline">\(\phi(x)m_n\)</span><br />3.<br/>4.return mean, <span class="math inline">\(\sigma ^2\)</span></td></tr></tbody></table><p>代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> multivariate_normal</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Polyfeature <span class="keyword">import</span> Polyfeature</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BLR</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n_features,alpha=<span class="number">0</span>,beta=<span class="number">1</span>,phi=<span class="string">&#x27;linear&#x27;</span></span>):</span><br><span class="line">        self.n_features=n_features</span><br><span class="line">        self.alpha=alpha</span><br><span class="line">        self.beta=beta</span><br><span class="line">        self.phi=phi</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    alpha 表示w的先验的精度</span></span><br><span class="line"><span class="string">    beta  表示数据的精度</span></span><br><span class="line"><span class="string">    phi   表示基函数，可选参数为：linear、gaussain、polynomial、sigmoid</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">gaussian</span>(<span class="params">self,x, mu, sigma</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> / (sigma * np.sqrt(<span class="number">2</span> * np.pi)) * np.exp(-(x - mu) ** <span class="number">2</span> / (<span class="number">2</span> * sigma ** <span class="number">2</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,X,t</span>):</span><br><span class="line">        <span class="comment"># 检查向量是否是二维数组并转化</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(X.shape) == <span class="number">1</span>:</span><br><span class="line">            X=X.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(t.shape) == <span class="number">1</span>:</span><br><span class="line">            t=t.reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 是否要0均值？</span></span><br><span class="line">        <span class="keyword">global</span> phi_x</span><br><span class="line">        <span class="keyword">global</span> x</span><br><span class="line">        <span class="keyword">if</span> self.phi==<span class="string">&#x27;linear&#x27;</span>:</span><br><span class="line">            phi_x=X</span><br><span class="line">            x=np.dot(phi_x,phi_x.T)</span><br><span class="line">        <span class="keyword">if</span> self.phi==<span class="string">&#x27;polynomial&#x27;</span>:</span><br><span class="line">            polyf=Polyfeature(self.n_features)</span><br><span class="line">            phi_x=polyf.fit_transform(X)</span><br><span class="line">            x=np.dot(phi_x.T,phi_x)</span><br><span class="line">        <span class="comment"># Sn的逆</span></span><br><span class="line">        Sn_inverse=self.alpha*np.eye(x.shape[<span class="number">0</span>])+self.beta*x</span><br><span class="line">        <span class="comment"># 计算期望</span></span><br><span class="line">        mn=self.beta*np.dot(np.dot(np.linalg.inv(Sn_inverse),phi_x.T),t)</span><br><span class="line"></span><br><span class="line">        self.phi_x=phi_x</span><br><span class="line">        self.Sn_inverse=Sn_inverse</span><br><span class="line">        self.mn=mn</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,X</span>):</span><br><span class="line">        <span class="keyword">if</span> self.phi==<span class="string">&#x27;linear&#x27;</span>:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">len</span>(X.shape)==<span class="number">1</span>:</span><br><span class="line">                X = X.reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">                sigma2=<span class="number">1</span>/self.beta+np.dot(np.dot(self.phi_x.T,np.linalg.inv(self.Sn_inverse)),self.phi_x)</span><br><span class="line">                t_pre=self.gaussian(X,self.mn,np.sqrt(sigma2))</span><br><span class="line">                <span class="keyword">return</span> t_pre</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> self.phi==<span class="string">&#x27;polynomial&#x27;</span>:</span><br><span class="line">            polyf=Polyfeature(self.n_features)</span><br><span class="line">            X=polyf.fit_transform(X)</span><br><span class="line"></span><br><span class="line">        sigma2 = np.diag(<span class="number">1</span> / self.beta + X @ np.linalg.inv(self.Sn_inverse) @ X.T).reshape(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">        mean=np.dot(X,self.mn)</span><br><span class="line"></span><br><span class="line">        upper = mean + np.sqrt(sigma2)</span><br><span class="line">        lower = mean - np.sqrt(sigma2)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> mean,sigma2,upper,lower</span><br></pre></td></tr></table></figure><p>回归效果：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/90e39f72c8da404c0738ddf8072aae4.png" alt="90e39f72c8da404c0738ddf8072aae4" style="zoom: 67%;" /></p><h2 id="不同样本数量影响拟合效果">不同样本数量影响拟合效果</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">   x_1=np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">    X_data=[np.array([<span class="number">0.5</span>]),</span><br><span class="line">                     np.array([<span class="number">0.3</span>,<span class="number">0.6</span>]),</span><br><span class="line">                     np.array([<span class="number">0.25</span>,<span class="number">0.5</span>,<span class="number">0.75</span>,<span class="number">0.8</span>]),</span><br><span class="line">                     np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">60</span>)]</span><br><span class="line">j=<span class="number">1</span></span><br><span class="line">plt.figure(figsize=(<span class="number">10</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> X_data:</span><br><span class="line">    plt.subplot(<span class="number">2</span>,<span class="number">2</span>,j)</span><br><span class="line">    t=np.sin(<span class="number">2</span>*np.pi*i)+np.random.normal(loc=<span class="number">0</span>,scale=<span class="number">0.2</span>,size=i.shape)</span><br><span class="line">    <span class="keyword">if</span> j&lt;<span class="number">2</span>:</span><br><span class="line">        blr = BLR(<span class="number">5</span>, phi=<span class="string">&#x27;polynomial&#x27;</span>,alpha=<span class="number">0.2</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;alpha=0.2&#x27;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        blr = BLR(<span class="number">4</span>, phi=<span class="string">&#x27;polynomial&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;without alpha&#x27;</span>)</span><br><span class="line">    j=j+<span class="number">1</span></span><br><span class="line">    <span class="comment"># 绘制sin原图像</span></span><br><span class="line">    plt.plot(x_1,np.sin(<span class="number">2</span>*np.pi*x_1),label=<span class="string">&#x27;sin(x)&#x27;</span>)</span><br><span class="line">    <span class="comment"># 绘制数据散点</span></span><br><span class="line">    plt.scatter(i, t, color=<span class="string">&#x27;g&#x27;</span>,label=<span class="string">&#x27;samples&#x27;</span>)</span><br><span class="line">    blr.fit(i, t)</span><br><span class="line">    plt.plot(x_1, blr.predict(x_1)[<span class="number">0</span>], color=<span class="string">&#x27;black&#x27;</span>,label=<span class="string">&#x27;prediction&#x27;</span>)</span><br><span class="line">    <span class="comment"># 绘制阴影部分</span></span><br><span class="line">    plt.fill_between(x_1.squeeze(), blr.predict(x_1)[<span class="number">3</span>].squeeze(), blr.predict(x_1)[<span class="number">2</span>].squeeze(), alpha=<span class="number">0.4</span>,label=<span class="string">&#x27;varience&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">    plt.ylabel(<span class="string">&#x27;t&#x27;</span>)</span><br><span class="line">plt.legend()</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408203151173.png"alt="image-20230408203151173" /><figcaption aria-hidden="true">image-20230408203151173</figcaption></figure><p>同时，我调整了样本数量较小时的<spanclass="math inline">\(\alpha\)</span>值，下图是无正则化的情况（样本数量为1时，必须有正则化否则出现奇异矩阵）：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408203316307.png"alt="image-20230408203316307" /><figcaption aria-hidden="true">image-20230408203316307</figcaption></figure><h2 id="交叉验证调优">交叉验证调优</h2><p>因为要做调优，所以固定生成数据，设定种子为0。</p><p>在固定<spanclass="math inline">\(\alpha=0,beta=10\)</span>时，首先确定degree：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408213637573.png" alt="image-20230408213637573" style="zoom:50%;" /></p><p>best degree is 9 min RMSE in test sets: 0.2014522467351943</p><p>接下来在<spanclass="math inline">\(degrer=9\)</span>的情况下，寻找<spanclass="math inline">\(\alpha\)</span>的参数最优情况：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408221238294.png" alt="image-20230408221238294" style="zoom:50%;" /></p><p>parameter_best is 2.848035868435799e-05</p><p>最后，按以上两种情况搜寻参数<spanclass="math inline">\(\beta\)</span>：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408221701245.png" alt="image-20230408221701245" style="zoom: 50%;" /></p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408221719701.png" alt="image-20230408221719701" style="zoom:50%;" /></p><p>beta_best is 14.84968262254465</p><p>最终参数选择结果为：</p><table><thead><tr class="header"><th><span class="math inline">\(\alpha\)</span></th><th>2.848035868435799e-05</th></tr></thead><tbody><tr class="odd"><td><span class="math inline">\(degree\)</span></td><td><strong>9</strong></td></tr><tr class="even"><td><span class="math inline">\(\beta\)</span></td><td><strong>14.84968262254465</strong></td></tr></tbody></table><p>最终拟合结果：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408222416810.png" alt="image-20230408222416810" style="zoom: 50%;" /></p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408222947483.png" alt="image-20230408222947483" style="zoom: 50%;" /></p><h2 id="模拟拟合过程似然先验">模拟拟合过程（似然、先验）</h2><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230408233948782.png" alt="image-20230408233948782" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy.stats <span class="keyword">import</span> multivariate_normal, norm</span><br><span class="line"><span class="keyword">from</span> numpy.random <span class="keyword">import</span> seed, uniform, randn</span><br><span class="line"><span class="keyword">from</span> numpy.linalg <span class="keyword">import</span> inv</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f</span>(<span class="params">x, a</span>):</span><br><span class="line">    <span class="keyword">return</span> a[<span class="number">0</span>] + a[<span class="number">1</span>] * x</span><br><span class="line"></span><br><span class="line">a = np.array([-<span class="number">0.3</span>, <span class="number">0.5</span>])</span><br><span class="line">N = <span class="number">30</span></span><br><span class="line">sigma = <span class="number">0.2</span></span><br><span class="line">X = uniform(-<span class="number">1</span>, <span class="number">1</span>, (N, <span class="number">1</span>))</span><br><span class="line">T = f(X, a) + randn(N, <span class="number">1</span>) * sigma</span><br><span class="line"></span><br><span class="line">beta = (<span class="number">1</span> / sigma) ** <span class="number">2</span> <span class="comment"># precision</span></span><br><span class="line">alpha = <span class="number">2.0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">posterior_w</span>(<span class="params">phi, t, S0, m0</span>):</span><br><span class="line">    SN = inv(inv(S0) + beta * Phi.T @ Phi)</span><br><span class="line">    mN = SN @ (inv(S0) @ m0 + beta * Phi.T @ t)</span><br><span class="line">    <span class="keyword">return</span> SN, mN</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sample_vals</span>(<span class="params">X, T, ix</span>):</span><br><span class="line">    x_in = X[ix]</span><br><span class="line">    Phi = np.c_[np.ones_like(x_in), x_in]</span><br><span class="line">    t = T[[ix]]</span><br><span class="line">    <span class="keyword">return</span> Phi, t</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_prior</span>(<span class="params">m, S, liminf=-<span class="number">1</span>, limsup=<span class="number">1</span>, step=<span class="number">0.05</span>, ax=plt, **kwargs</span>):</span><br><span class="line">    grid = np.mgrid[liminf:limsup + step:step, liminf:limsup + step:step]</span><br><span class="line">    nx = grid.shape[-<span class="number">1</span>]</span><br><span class="line">    z = multivariate_normal.pdf(grid.T.reshape(-<span class="number">1</span>, <span class="number">2</span>), mean=m.ravel(), cov=S).reshape(nx, nx).T</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ax.contourf(*grid, z, cmap=<span class="string">&#x27;jet&#x27;</span>,interpolation=<span class="string">&#x27;nearest&#x27;</span>,**kwargs)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_sample_w</span>(<span class="params">mean, cov, size=<span class="number">10</span>, ax=plt</span>):</span><br><span class="line">    w = np.random.multivariate_normal(mean=mean.ravel(), cov=cov, size=size)</span><br><span class="line">    x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">for</span> wi <span class="keyword">in</span> w:</span><br><span class="line">        ax.plot(x, f(x, wi), c=<span class="string">&quot;tab:blue&quot;</span>, alpha=<span class="number">0.4</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">plot_likelihood_obs</span>(<span class="params">X, T, ix, ax=plt</span>):</span><br><span class="line">    W = np.mgrid[-<span class="number">1</span>:<span class="number">1</span>:<span class="number">0.1</span>, -<span class="number">1</span>:<span class="number">1</span>:<span class="number">0.1</span>]</span><br><span class="line">    x, t = sample_vals(X, T, ix)</span><br><span class="line">    mean = W.T.reshape(-<span class="number">1</span>, <span class="number">2</span>) @ x.T</span><br><span class="line"></span><br><span class="line">    likelihood = norm.pdf(t, loc=mean, scale=np.sqrt(<span class="number">1</span> / beta)).reshape(<span class="number">20</span>, <span class="number">20</span>).T</span><br><span class="line">    ax.contourf(*W, likelihood,cmap=<span class="string">&#x27;jet&#x27;</span>,interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">    ax.scatter(-<span class="number">0.3</span>, <span class="number">0.5</span>, c=<span class="string">&quot;white&quot;</span>, marker=<span class="string">&quot;+&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SN = np.eye(<span class="number">2</span>) / alpha</span><br><span class="line">mN = np.zeros((<span class="number">2</span>, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">seed(<span class="number">1643</span>)</span><br><span class="line">N = <span class="number">20</span></span><br><span class="line">nobs = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">20</span>]</span><br><span class="line">ix_fig = <span class="number">1</span></span><br><span class="line">fig, ax = plt.subplots(<span class="built_in">len</span>(nobs) + <span class="number">1</span>, <span class="number">3</span>, figsize=(<span class="number">10</span>, <span class="number">12</span>))</span><br><span class="line">plot_prior(mN, SN, ax=ax[<span class="number">0</span>, <span class="number">1</span>])</span><br><span class="line">ax[<span class="number">0</span>, <span class="number">1</span>].scatter(-<span class="number">0.3</span>, <span class="number">0.5</span>, c=<span class="string">&quot;white&quot;</span>, marker=<span class="string">&quot;+&quot;</span>)</span><br><span class="line">ax[<span class="number">0</span>, <span class="number">0</span>].axis(<span class="string">&quot;off&quot;</span>)</span><br><span class="line">plot_sample_w(mN, SN, ax=ax[<span class="number">0</span>, <span class="number">2</span>])</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, N + <span class="number">1</span>):</span><br><span class="line">    Phi, t = sample_vals(X, T, i)</span><br><span class="line">    SN, mN = posterior_w(Phi, t, SN, mN)</span><br><span class="line">    <span class="keyword">if</span> i + <span class="number">1</span> <span class="keyword">in</span> nobs:</span><br><span class="line">        plot_likelihood_obs(X, T, i, ax=ax[ix_fig, <span class="number">0</span>])</span><br><span class="line">        plot_prior(mN, SN, ax=ax[ix_fig, <span class="number">1</span>])</span><br><span class="line">        ax[ix_fig, <span class="number">1</span>].scatter(-<span class="number">0.3</span>, <span class="number">0.5</span>, c=<span class="string">&quot;white&quot;</span>, marker=<span class="string">&quot;+&quot;</span>)</span><br><span class="line">        ax[ix_fig, <span class="number">2</span>].scatter(X[:i + <span class="number">1</span>], T[:i + <span class="number">1</span>], c=<span class="string">&quot;crimson&quot;</span>)</span><br><span class="line">        ax[ix_fig, <span class="number">2</span>].set_xlim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        ax[ix_fig, <span class="number">2</span>].set_ylim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">for</span> l <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">            ax[ix_fig, l].set_xlabel(<span class="string">&quot;$w_0$&quot;</span>)</span><br><span class="line">            ax[ix_fig, l].set_ylabel(<span class="string">&quot;$w_1$&quot;</span>)</span><br><span class="line">        plot_sample_w(mN, SN, ax=ax[ix_fig, <span class="number">2</span>])</span><br><span class="line">        ix_fig += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">titles = [<span class="string">&quot;likelihood&quot;</span>, <span class="string">&quot;prior/posterior&quot;</span>, <span class="string">&quot;data space&quot;</span>]</span><br><span class="line"><span class="keyword">for</span> axi, title <span class="keyword">in</span> <span class="built_in">zip</span>(ax[<span class="number">0</span>], titles):</span><br><span class="line">    axi.set_title(title, size=<span class="number">15</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><h1 id="作业五">作业五</h1><h2 id="等价核绘制">等价核绘制</h2><p>首先是高斯核的绘制，下图是一个取值为线性的高斯核函数的图像<img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402182640901.png" alt="image-20230402182640901" style="zoom: 80%;" /></p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402182755965.png" alt="image-20230402182755965" style="zoom:67%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussianLike</span>(<span class="params">mu,sigma,x</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp((-<span class="number">1</span>/<span class="number">2</span>)*np.matmul(np.matmul((x-mu),np.linalg.inv(sigma)),(x-mu).reshape(<span class="built_in">len</span>(x),<span class="number">1</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussianKernel</span>(<span class="params">gaussianLike,x</span>):</span><br><span class="line">    <span class="keyword">return</span> np.dot(gaussianLike(np.zeros(<span class="number">2</span>,),np.eye(<span class="number">2</span>,<span class="number">2</span>),x),gaussianLike(np.zeros(<span class="number">2</span>,),np.eye(<span class="number">2</span>,<span class="number">2</span>),x))</span><br><span class="line"></span><br><span class="line">x=np.linspace(-<span class="number">2</span>,<span class="number">2</span>,<span class="number">100</span>)</span><br><span class="line">y=np.linspace(-<span class="number">2</span>,<span class="number">2</span>,<span class="number">100</span>)</span><br><span class="line">X, Y = np.meshgrid(x, y)</span><br><span class="line">Z=[]</span><br><span class="line">z1=np.ones((<span class="number">100</span>,<span class="number">100</span>))</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> x:</span><br><span class="line">    n=<span class="number">0</span></span><br><span class="line">    z=[]</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> y:</span><br><span class="line">        m=<span class="number">0</span></span><br><span class="line">        z.append(gaussianKernel(gaussianLike,[i,j]))</span><br><span class="line">        z1[n,m]=gaussianKernel(gaussianLike,[i,j])</span><br><span class="line">        m+=<span class="number">1</span></span><br><span class="line">    n+=<span class="number">1</span></span><br><span class="line">    Z.append(z)</span><br><span class="line">Z=np.array(Z)</span><br><span class="line"></span><br><span class="line">plt.imshow(Z,cmap=<span class="string">&#x27;hot&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">ax.plot_surface(X,Y,Z,cmap=<span class="string">&#x27;rainbow&#x27;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>下面复现课本的等价核：</p><p><strong>高斯核</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian_kernel</span>(<span class="params">x, y, sigma</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(-np.linalg.norm(x - y)**<span class="number">2</span> / (<span class="number">2</span> * (sigma ** <span class="number">2</span>)))</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_kernel_matrix</span>(<span class="params">X, sigma</span>):</span><br><span class="line">    n = X.shape[<span class="number">0</span>]</span><br><span class="line">    K = np.zeros((n, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            K[i, j] = gaussian_kernel(X[i], X[j], sigma)</span><br><span class="line">            K[j, i] = K[i, j]</span><br><span class="line">    <span class="keyword">return</span> K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据集</span></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同带宽参数下的高斯等价核矩阵</span></span><br><span class="line">sigmas = [<span class="number">0.1</span>, <span class="number">1</span>, <span class="number">10</span>]</span><br><span class="line"><span class="keyword">for</span> sigma <span class="keyword">in</span> sigmas:</span><br><span class="line">    K = compute_kernel_matrix(X, sigma)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 绘制高斯核形状图像</span></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.imshow(K, cmap=<span class="string">&#x27;jet&#x27;</span>, interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">    plt.title(<span class="string">r&#x27;Gaussian Kernel with $\sigma=$&#x27;</span> + <span class="built_in">str</span>(sigma))</span><br><span class="line">    plt.colorbar()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183003203.png"alt="image-20230402183003203" /><figcaption aria-hidden="true">image-20230402183003203</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183010833.png"alt="image-20230402183010833" /><figcaption aria-hidden="true">image-20230402183010833</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183017836.png"alt="image-20230402183017836" /><figcaption aria-hidden="true">image-20230402183017836</figcaption></figure><p><strong>多项式核</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">polynomial_kernel</span>(<span class="params">x, y, degree, coef0=<span class="number">0</span></span>):</span><br><span class="line">    <span class="keyword">return</span> (np.dot(x, y) + coef0) ** degree</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_kernel_matrix</span>(<span class="params">X, degree, coef0=<span class="number">0</span></span>):</span><br><span class="line">    n = X.shape[<span class="number">0</span>]</span><br><span class="line">    K = np.zeros((n, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            K[i, j] = polynomial_kernel(X[i], X[j], degree, coef0)</span><br><span class="line">            K[j, i] = K[i, j]</span><br><span class="line">    <span class="keyword">return</span> K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据集</span></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同阶数和常数项参数下的多项式核矩阵</span></span><br><span class="line">degrees = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line">coef0s = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> degree <span class="keyword">in</span> degrees:</span><br><span class="line">    <span class="keyword">for</span> coef0 <span class="keyword">in</span> coef0s:</span><br><span class="line">        K = compute_kernel_matrix(X, degree, coef0)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制多项式核形状图像</span></span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.imshow(K, cmap=<span class="string">&#x27;jet&#x27;</span>, interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;Polynomial Kernel with degree=&#x27;</span> + <span class="built_in">str</span>(degree) + <span class="string">&#x27; and coef0=&#x27;</span> + <span class="built_in">str</span>(coef0))</span><br><span class="line">        plt.colorbar()</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183116818.png"alt="image-20230402183116818" /><figcaption aria-hidden="true">image-20230402183116818</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183128404.png"alt="image-20230402183128404" /><figcaption aria-hidden="true">image-20230402183128404</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183137656.png"alt="image-20230402183137656" /><figcaption aria-hidden="true">image-20230402183137656</figcaption></figure><p><strong>Sigmoid核</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigmoid_kernel</span>(<span class="params">x, y, alpha, c</span>):</span><br><span class="line">    <span class="keyword">return</span> np.tanh(alpha * np.dot(x, y) + c)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">compute_kernel_matrix</span>(<span class="params">X, alpha, c</span>):</span><br><span class="line">    n = X.shape[<span class="number">0</span>]</span><br><span class="line">    K = np.zeros((n, n))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i, n):</span><br><span class="line">            K[i, j] = sigmoid_kernel(X[i], X[j], alpha, c)</span><br><span class="line">            K[j, i] = K[i, j]</span><br><span class="line">    <span class="keyword">return</span> K</span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成示例数据集</span></span><br><span class="line">X = np.linspace(-<span class="number">5</span>, <span class="number">5</span>, <span class="number">100</span>).reshape(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">y = np.sin(X)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算不同超参数下的 Sigmoid 核矩阵</span></span><br><span class="line">alphas = [<span class="number">0.1</span>, <span class="number">0.5</span>, <span class="number">1</span>]</span><br><span class="line">cs = [-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line"><span class="keyword">for</span> alpha <span class="keyword">in</span> alphas:</span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> cs:</span><br><span class="line">        K = compute_kernel_matrix(X, alpha, c)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 绘制 Sigmoid 核形状图像</span></span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.imshow(K, cmap=<span class="string">&#x27;jet&#x27;</span>, interpolation=<span class="string">&#x27;nearest&#x27;</span>)</span><br><span class="line">        plt.title(<span class="string">&#x27;Sigmoid Kernel with alpha=&#x27;</span> + <span class="built_in">str</span>(alpha) + <span class="string">&#x27; and c=&#x27;</span> + <span class="built_in">str</span>(c))</span><br><span class="line">        plt.colorbar()</span><br><span class="line">        plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183249517.png"alt="image-20230402183249517" /><figcaption aria-hidden="true">image-20230402183249517</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183257364.png"alt="image-20230402183257364" /><figcaption aria-hidden="true">image-20230402183257364</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402183304889.png"alt="image-20230402183304889" /><figcaption aria-hidden="true">image-20230402183304889</figcaption></figure><h2 id="似然">似然</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> stats</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line">random.seed(<span class="number">615</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_synth_data</span>(<span class="params">N, beta</span>):</span><br><span class="line">    X_N =np.random.uniform(-<span class="number">1</span>,<span class="number">1</span>, N)</span><br><span class="line">    X_N = np.column_stack((np.ones(N), X_N))</span><br><span class="line">    <span class="comment"># for this example the true function is f(x,a) = a_0 + a_1*x</span></span><br><span class="line">    <span class="comment"># where a_0 = -.3 and a_1 = .5 are the parameters that we</span></span><br><span class="line">    <span class="comment"># are going to estimate</span></span><br><span class="line">    a = np.array([-<span class="number">.3</span>, <span class="number">.5</span>])</span><br><span class="line">    t = np.dot(X_N, a)</span><br><span class="line">    <span class="keyword">return</span> X_N, t + np.random.normal(loc=<span class="number">0.0</span>, scale=np.sqrt(<span class="number">1.</span>/beta), size=N)</span><br><span class="line"></span><br><span class="line">beta_ = <span class="number">25.0</span></span><br><span class="line">alpha = <span class="number">2.0</span></span><br><span class="line">N = <span class="number">20</span></span><br><span class="line">X_N, t_N = get_synth_data(N, beta_)</span><br><span class="line">x = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">70</span>)</span><br><span class="line">y = np.linspace(-<span class="number">1</span>, <span class="number">1</span>, <span class="number">70</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">w0, w1 = np.meshgrid(x, y)</span><br><span class="line">m_0 = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">S_0 = <span class="number">1</span>/alpha * np.eye(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">1</span></span><br><span class="line">X_n = X_N[<span class="built_in">range</span>(n), :]</span><br><span class="line">t_n = t_N[<span class="built_in">range</span>(n)]</span><br><span class="line">plt.xlim(-<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">plt.ylim(-<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">plt.scatter(X_n[:, <span class="number">1</span>], t_n)</span><br><span class="line">plt.title(<span class="string">&quot;First point in the data set&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;x&#x27;</span>);</span><br><span class="line">plt.ylabel(<span class="string">&#x27;y&#x27;</span>)</span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">likelihood</span>(<span class="params">t_, x, w, beta</span>):</span><br><span class="line">    <span class="keyword">from</span> math <span class="keyword">import</span> sqrt</span><br><span class="line">    <span class="keyword">return</span> stats.norm.pdf(t_,loc=np.dot(w,x), scale=sqrt(<span class="number">1.</span>/beta))</span><br><span class="line"></span><br><span class="line">Z = np.zeros((<span class="built_in">len</span>(y), <span class="built_in">len</span>(x)))</span><br><span class="line"><span class="keyword">for</span> i, w1 <span class="keyword">in</span> <span class="built_in">enumerate</span>(y):</span><br><span class="line">    <span class="keyword">for</span> j, w0 <span class="keyword">in</span> <span class="built_in">enumerate</span>(x):</span><br><span class="line">        Z[i, j] = likelihood(t_n[-<span class="number">1</span>], X_n[-<span class="number">1</span>,:], np.array([w0, w1]), beta_)</span><br><span class="line">extent = (-<span class="number">1</span>,<span class="number">1</span>,-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.imshow(Z, extent=extent, origin=<span class="string">&#x27;lower&#x27;</span>)</span><br><span class="line">plt.plot(-<span class="number">0.3</span>, <span class="number">0.5</span>, <span class="string">&#x27;w+&#x27;</span>, markeredgewidth=<span class="number">2</span>, markersize=<span class="number">12</span>)</span><br><span class="line">plt.title(<span class="string">&quot;Likelihood of the first point in the data set, white cross = true value&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&quot;w0&quot;</span>)</span><br><span class="line">plt.ylabel(<span class="string">&quot;w1&quot;</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402184647229.png"alt="image-20230402184647229" /><figcaption aria-hidden="true">image-20230402184647229</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402184827621.png"alt="image-20230402184827621" /><figcaption aria-hidden="true">image-20230402184827621</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230402184922104.png"alt="image-20230402184922104" /><figcaption aria-hidden="true">image-20230402184922104</figcaption></figure><h1 id="作业一-多项式拟合">作业一 多项式拟合</h1><h2 id="理论推导">理论推导</h2><p><span class="math display">\[\min ||f(\omega;x)-t||^2\\\sum_{i=0}^{n}{\omega_i*x_i^j}=t\]</span></p><p>写成矩阵形式： <span class="math display">\[XW=T\]</span> 使用平方和最小来衡量，设损失函数： <spanclass="math display">\[L(x)=\frac{1}{2}\sum^{N}_{i=1}{(\sum_{j=0}^{M}{\omega_jx_i^j-y_i)^2}}\]</span> 对损失函数求导，令导数等于0： <span class="math display">\[\begin{array}{l}\frac{\partial L(x;\omega)}{\partial \omega_i}=0 \\\\\frac{1}{2}\sum_{i=1}^{N}{2(\sum^{j=0}_{M}{\omega_jx_i^j-y_i)}\timesx_i^k}=0 \\\\\sum_{i=1}^{N}{\sum^{M}_{j=1}{\omega_ix_i^{j+k}}}=\sum_{j=1}^{M}{x_i^ky_i}(k=0,1,2,3,\cdots,M)\end{array}\]</span> 那么就有： <span class="math display">\[\begin{array}{l}X=\sum^M_{j=1}{x_i^{j+k}} \\W=\omega_i \\Y=\sum_{i=1}^{M}{x_i^ky_i}\\XW=Y\end{array}\]</span> 将以<spanclass="math inline">\(x\)</span>为参数的非线性模型转化为以<spanclass="math inline">\(w\)</span>的线性模型，从而转化为矩阵方程求解问题,需要将方程特征进行组合，实现上使用sklearn，进行多项式特征组合，然后使用线性回归进行预测：</p><p>算法语言描述：</p><ol type="1"><li><p>生成一个（特征数目+1，特征数目+1）的矩阵</p></li><li><p>分别计算0-特征阶数的幂</p></li><li><p>返回特征混合矩阵</p></li><li><p>线性回归</p></li></ol><h2 id="代码实现">代码实现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polyfeature</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n_features</span>):</span><br><span class="line">        self.n_features=n_features</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一元特征混合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, x</span>):</span><br><span class="line">        xf = np.zeros((<span class="built_in">len</span>(x), self.n_features + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_features + <span class="number">1</span>):</span><br><span class="line">            xf[:,i] = np.power(x, i).reshape(np.shape(xf[:,i]))</span><br><span class="line">        self.xf=xf</span><br><span class="line">        <span class="keyword">return</span> xf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">transform</span>(<span class="params">self,x</span>):</span><br><span class="line">        xf = np.zeros((<span class="built_in">len</span>(x), self.n_features + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_features + <span class="number">1</span>):</span><br><span class="line">            xf[:, i] = np.power(x, i).reshape(np.shape(xf[:, i]))</span><br><span class="line">        self.xf = xf</span><br><span class="line">        <span class="keyword">return</span> xf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit_transform</span>(<span class="params">self, x</span>):</span><br><span class="line">        xf = np.zeros((<span class="built_in">len</span>(x), self.n_features + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_features + <span class="number">1</span>):</span><br><span class="line">            xf[:, i] = np.power(x, i).reshape(np.shape(xf[:, i]))</span><br><span class="line">            self.xf = xf</span><br><span class="line">        <span class="keyword">return</span> xf</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">linearregression</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,x,y,Lambda=<span class="number">0</span></span>):</span><br><span class="line">        c = np.dot(x.T, x)</span><br><span class="line">        I = np.eye(np.shape(c)[<span class="number">0</span>])</span><br><span class="line">        d = np.dot(Lambda, I)</span><br><span class="line">        e = (c + d)</span><br><span class="line">        e = np.linalg.inv(e)</span><br><span class="line">        w = np.dot(x.T, y)</span><br><span class="line">        w = np.dot(e, w)</span><br><span class="line">        self.w = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,x</span>):</span><br><span class="line">        y=np.dot(x,self.w)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.preprocessing <span class="keyword">import</span> PolynomialFeatures</span><br><span class="line"><span class="keyword">from</span> sklearn.linear_model <span class="keyword">import</span> LinearRegression</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">polyregression</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,features</span>):</span><br><span class="line">        self.n_features=features</span><br><span class="line">    <span class="comment"># 生成数据</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">create_data</span>(<span class="params">self,n</span>):</span><br><span class="line">        self.n=n</span><br><span class="line">        X=np.random.rand(n,<span class="number">1</span>)</span><br><span class="line">        <span class="comment"># 考虑到需要保证高斯白噪声的0均值</span></span><br><span class="line">        noise=<span class="number">0.3</span>*np.random.uniform(low=-<span class="number">1</span>, high=<span class="number">1</span>, size=(n,<span class="number">1</span>))</span><br><span class="line">        t=np.sin(X*<span class="number">2</span>*math.pi)+noise</span><br><span class="line">        self.X=X</span><br><span class="line">        self.t=t</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 划分数据集</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">splitData</span>(<span class="params">self</span>):</span><br><span class="line">        X_train, X_test, T_train, T_test = train_test_split(self.X, self.t, test_size=<span class="number">0.3</span>, random_state=<span class="number">0</span>)</span><br><span class="line">        self.X_train=X_train</span><br><span class="line">        self.X_test=X_test</span><br><span class="line">        self.T_train=T_train</span><br><span class="line">        self.T_test=T_test</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 多项式拟合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self</span>):</span><br><span class="line">        poly = PolynomialFeatures(self.n_features)</span><br><span class="line">        x_train_poly = poly.fit_transform(self.X_train)</span><br><span class="line"></span><br><span class="line">        lin=LinearRegression()</span><br><span class="line">        lin.fit(x_train_poly,self.T_train)</span><br><span class="line"></span><br><span class="line">        self.lin=lin</span><br><span class="line">        self.poly=poly</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self</span>):</span><br><span class="line">        plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>),np.sin(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>)*<span class="number">2</span>*math.pi),color=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">        plt.scatter(self.X,self.t,marker=<span class="string">&#x27;o&#x27;</span>,edgecolor=<span class="string">&#x27;blue&#x27;</span>,color=<span class="string">&#x27;white&#x27;</span>,linewidths=<span class="string">&#x27;1.1&#x27;</span>)</span><br><span class="line">        plt.plot(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>),self.lin.predict(self.poly.transform(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>).reshape(-<span class="number">1</span>,<span class="number">1</span>))),color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        s=<span class="string">&#x27;n_features=&#x27;</span>+<span class="built_in">str</span>(self.n_features)</span><br><span class="line">        plt.text(<span class="number">0.7</span>,<span class="number">1</span>,s)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">        plt.savefig(<span class="string">&#x27;features=&#x27;</span>+<span class="built_in">str</span>(self.n_features)+<span class="string">&#x27; samples=&#x27;</span>+<span class="built_in">str</span>(self.n)+<span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">    <span class="comment"># 衡量拟合的标准</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">RSME</span>(<span class="params">self</span>):</span><br><span class="line">        T_test_predict=self.lin.predict(self.poly.transform(self.X_test))</span><br><span class="line">        SSE=np.<span class="built_in">sum</span>(np.square(self.T_test-T_test_predict))</span><br><span class="line">        MSE=SSE/<span class="built_in">len</span>(T_test_predict)</span><br><span class="line">        rsme=np.sqrt(MSE)</span><br><span class="line">        <span class="keyword">return</span> rsme</span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="comment"># 对不同特征选择的比较</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">features_test</span>():</span><br><span class="line">        RSME=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">            poly=polyregression(i)</span><br><span class="line">            poly.create_data(<span class="number">20</span>)</span><br><span class="line">            poly.splitData()</span><br><span class="line">            poly.fit()</span><br><span class="line">            poly.draw()</span><br><span class="line">            RSME.append(poly.RSME())</span><br><span class="line"></span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot(np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>),RSME,marker=<span class="string">&#x27;^&#x27;</span>,label=<span class="string">&quot;points&quot;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line">    <span class="comment"># 对不同样本数量的比较</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">samples_test</span>():</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> [<span class="number">20</span>,<span class="number">200</span>,<span class="number">500</span>]:</span><br><span class="line">            RSME=[]</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">                poly=polyregression(i)</span><br><span class="line">                poly.create_data(j)</span><br><span class="line">                poly.splitData()</span><br><span class="line">                poly.fit()</span><br><span class="line">                poly.draw()</span><br><span class="line">                RSME.append(poly.RSME())</span><br><span class="line">            plt.figure()</span><br><span class="line">            plt.plot(np.linspace(<span class="number">0</span>,<span class="number">50</span>,<span class="number">50</span>),RSME,marker=<span class="string">&#x27;^&#x27;</span>,label=<span class="string">&quot;points&quot;</span>)</span><br><span class="line">            plt.savefig(<span class="string">&#x27;sample=&#x27;</span>+<span class="built_in">str</span>(j)+<span class="string">&#x27;.png&#x27;</span>)</span><br><span class="line">            plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="comment"># features_test()</span></span><br><span class="line">    samples_test()</span><br></pre></td></tr></table></figure><h2 id="结果对比">结果对比</h2><p>不同的特征数量，首先全部针对样本数量为10的情况： <imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=0%20samples=10.png"alt="features=0 samples=10" /></p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=1%20samples=10.png"alt="features=1 samples=10" /><figcaption aria-hidden="true">features=1 samples=10</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=2%20samples=10.png"alt="features=2 samples=10" /><figcaption aria-hidden="true">features=2 samples=10</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=3%20samples=10.png"alt="features=3 samples=10" /><figcaption aria-hidden="true">features=3 samples=10</figcaption></figure><figure><imgsrc="G:\专业学习\第六学期\机器学习\实验一\selectF\features=4%20samples=10.png"alt="features=4 samples=10" /><figcaption aria-hidden="true">features=4 samples=10</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=5%20samples=10.png"alt="features=5 samples=10" /><figcaption aria-hidden="true">features=5 samples=10</figcaption></figure><p>从中可以大致看出，在选择特征过少时，会出现欠拟合现象，选择过多后则会过拟合，针对样本量为20的情况下，RSME曲线如图：<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/sample=20.png"alt="sample=20.png" />图上显示的情况，并不是与我们预期中的情况完全吻合，其原因可能是因为测试集样本数量过少，导致无法很好的捕捉曲线拟合的问题，于是我们对其他样本数量进行对比、 <imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/sample=200.png"alt="sample=200.png" /> <imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/sample=500.png"alt="sample=500.png" /><br />可以看出样本数量增多后，特征的选择有明显的趋势。尝试复现使用样本为10的情况：<imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/sample=10.png"alt="sample=10" /> 且样本数量会明显的影响拟合的效果。</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=5%20samples=10.png"alt="features=5 samples=10" /><figcaption aria-hidden="true">features=5 samples=10</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=5%20samples=20.png"alt="features=5 samples=20" /><figcaption aria-hidden="true">features=5 samples=20</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=5%20samples=200.png"alt="features=5 samples=200" /><figcaption aria-hidden="true">features=5 samples=200</figcaption></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/features=5%20samples=500.png"alt="features=5 samples=500" /><figcaption aria-hidden="true">features=5 samples=500</figcaption></figure><p>针对样本为10，特征为5的情况下进行正则化：</p><p><span class="math inline">\(\lambda\)</span>=0.7740859059011267</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230311220541756.png"alt="image-20230311220541756" /><figcaption aria-hidden="true">image-20230311220541756</figcaption></figure><h1 id="作业二">作业二</h1><h2 id="频率学派与贝叶斯学派">频率学派与贝叶斯学派</h2><ul><li>频率观点认为频率能够趋近概率，模型的参数是一定的，只要采样数目足够多就能逼近参数值，我的理解是其符合大数定律的思想（此为辛钦大数定律）：<span class="math display">\[\lim_{n\to\infty}P\left(\left|\frac{1}{n}\sum_{i=1}^{n}{a_i-\mu}  \right|&lt;\varepsilon\right)=1\]</span></li><li>贝叶斯观点认为模型的参数是在变化的，样本是一定的。 <spanclass="math display">\[p(w|D)=\frac{p(D|w)p(w)}{p(D)}\]</span> 以一元高斯分布为例，解释样本分布问题：</li><li>频率：频率的思想是以样本代替总体，从而得到模型参数，假设有数据集<spanclass="math inline">\(D=\{x_1,x_2,\cdot\cdot\cdot,x_n\}\)</span>，则估计得到的一元高斯分布的参数为<span class="math display">\[\hat\mu=\frac{1}{n}\sum_{i=1}^{n}{x_i}\]</span> <span class="math display">\[\hat{\sigma^2}=\frac{1}{n}\sum_{i=1}^{n}{(x_i-\hat\mu)}^2\]</span>样本分布显然是和总体有差异的，对其求期望可以得到，均值为无偏估计，而方差存在偏差，而偏差随着样本数目n的增大而减小（<spanclass="math inline">\(E(\hat\sigma^2)=\frac{n-1}{n}\sigma^2\)</span>）。</li><li>贝叶斯：贝叶斯的思想认为所有参数都是一个分布，而样本是固定不变的量。所以通过先验尽可能使逼近高斯分布。<span class="math display">\[p(D|w)=\frac{p(w|D)p(D)}{p(w)}\]</span> 有似然函数，其中<spanclass="math inline">\(p(D)\)</span>为一个常数，可被忽略（归一化），根据课本给出的高斯分布求解结果，发现他的方差和均值均为无偏估计。## 公式推导 <imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230421154051248.png"alt="image-20230421154051248" /></li></ul><p>引入先验</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230421154116419.png"alt="image-20230421154116419" /><figcaption aria-hidden="true">image-20230421154116419</figcaption></figure><p>在这里将数据的概率分布进行了归一，认为样本概率为一常数</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230421154257436.png"alt="image-20230421154257436" /><figcaption aria-hidden="true">image-20230421154257436</figcaption></figure><p>然后对<span class="math inline">\(\lnp(\mathbf{w}|\alpha)\)</span>求解：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230421154321678.png"alt="image-20230421154321678" /><figcaption aria-hidden="true">image-20230421154321678</figcaption></figure><p>取负数：<br /><span class="math display">\[-\ln p(\mathbf{t|x},w,\beta)p(\mathbf{w}|\alpha)=\frac{\beta}{2}\sum_{n=1}^{N}{(x-y_n(x_n,\mathbf{w}))^2 }+\frac{\alpha}{2}\mathbf{w^T}\mathbf{w}-\frac{n}{2}\ln \frac{\beta}{2\pi}-\frac{M+1}{2}\ln \alpha+\frac{M+1}{2}\ln 2\pi\]</span> 后三项均为常数，对最大化没有任何影响，因此损失函数为：</p><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230421154342936.png"alt="image-20230421154342936" /><figcaption aria-hidden="true">image-20230421154342936</figcaption></figure><h1 id="作业三">作业三</h1><h2 id="基函数图像复现">基函数图像复现</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> matplotlib.ticker <span class="keyword">import</span> MultipleLocator</span><br><span class="line"></span><br><span class="line">x_major_locator=MultipleLocator(<span class="number">1</span>)</span><br><span class="line">y_major_locator=MultipleLocator(<span class="number">0.25</span>)</span><br><span class="line"></span><br><span class="line">plt.figure(figsize=(<span class="number">15</span>,<span class="number">5</span>))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">sigma</span>(<span class="params">x,b</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>/(np.exp((-x+b)*<span class="number">10</span>)+<span class="number">1</span>)</span><br><span class="line">x=np.linspace(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">100</span>)</span><br><span class="line">b=np.linspace(-<span class="number">1</span>,<span class="number">1</span>,<span class="number">11</span>).tolist()</span><br><span class="line"><span class="keyword">for</span> bi <span class="keyword">in</span> b:</span><br><span class="line">    plt.plot(x,sigma(x,bi))</span><br><span class="line">plt.xlim(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">ax=plt.gca()</span><br><span class="line">ax.xaxis.set_major_locator(x_major_locator)</span><br><span class="line">ax.yaxis.set_major_locator(y_major_locator)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">def gaussian(mu,sigma,x,b):</span></span><br><span class="line"><span class="string">    return 1/(np.sqrt(2*np.pi)*sigma)*np.exp(-np.square((x+b)*5-mu)/2*np.square(sigma))</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">plt.subplot(1,3,2)</span></span><br><span class="line"><span class="string">for bi in b:</span></span><br><span class="line"><span class="string">    plt.plot(x,gaussian(0,1,x,bi))</span></span><br><span class="line"><span class="string">plt.xlim(-1,1)</span></span><br><span class="line"><span class="string">plt.ylim(0,0.4)</span></span><br><span class="line"><span class="string">plt.show()</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">poly</span>(<span class="params">x,n</span>):</span><br><span class="line">    <span class="keyword">return</span> np.power(x,n)</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>)</span><br><span class="line">n=np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>).tolist()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> n:</span><br><span class="line">    plt.plot(x,poly(x,i))</span><br><span class="line">plt.xlim(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.ylim(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">ax=plt.gca()</span><br><span class="line">y_major_locator1=MultipleLocator(<span class="number">0.5</span>)</span><br><span class="line">ax.xaxis.set_major_locator(x_major_locator)</span><br><span class="line">ax.yaxis.set_major_locator(y_major_locator1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">gaussian1</span>(<span class="params">mu,sigma,x,b</span>):</span><br><span class="line">    <span class="keyword">return</span> np.exp(-np.square((x+b)*<span class="number">5</span>-mu)/<span class="number">2</span>*np.square(sigma))</span><br><span class="line">plt.subplot(<span class="number">1</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> bi <span class="keyword">in</span> b:</span><br><span class="line">    plt.plot(x,gaussian1(<span class="number">0</span>,<span class="number">1</span>,x,bi))</span><br><span class="line"></span><br><span class="line">ax=plt.gca()</span><br><span class="line">ax.xaxis.set_major_locator(x_major_locator)</span><br><span class="line">ax.yaxis.set_major_locator(y_major_locator)</span><br><span class="line"></span><br><span class="line">plt.xlim(-<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">plt.ylim(<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><figure><imgsrc="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230317214519144.png"alt="image-20230317214519144" /><figcaption aria-hidden="true">image-20230317214519144</figcaption></figure><h1 id="作业四-多项式拟合加强版">作业四 多项式拟合（加强版）</h1><h2 id="实验项目结构">实验项目结构</h2><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326184103754.png" alt="image-20230326184103754" style=" float:left" />/&gt;其中，data储存固化的数据</p><p>将数据生成函数与多项式拟合功能分离，建立createData.py</p><p>交叉验证函数</p><p>线性回归</p><p>多项式特征生成和多项式回归</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">createData.py</span><br><span class="line">__________________</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成数据集</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">create_data</span>(<span class="params">n,beta</span>):</span><br><span class="line">    n = n</span><br><span class="line">    X = np.linspace(<span class="number">0</span>, <span class="number">1</span>, n).reshape(n, <span class="number">1</span>)</span><br><span class="line">    noise = beta * np.random.uniform(low=-<span class="number">1</span>, high=<span class="number">1</span>, size=(n, <span class="number">1</span>))</span><br><span class="line">    t = np.sin(X * <span class="number">2</span> * np.pi) + noise</span><br><span class="line">    X = X</span><br><span class="line">    t = t</span><br><span class="line">    data=np.hstack((X,t))</span><br><span class="line">    <span class="keyword">return</span> data</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">splitData</span>(<span class="params">X,t</span>):</span><br><span class="line">    X_train, X_test, T_train, T_test = train_test_split(X, t, test_size=<span class="number">0.2</span>, random_state=<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">return</span> X_train,X_test,T_train,T_test</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据固化</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">tocsv</span>(<span class="params">data</span>):</span><br><span class="line">    df=pd.DataFrame(data)</span><br><span class="line">    df.to_csv(<span class="string">&#x27;.\data\sample=&#x27;</span>+<span class="built_in">str</span>(data.shape[<span class="number">0</span>])+<span class="string">&#x27;.csv&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    data=create_data(<span class="number">10</span>,<span class="number">0.1</span>)</span><br><span class="line">    tocsv(data)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Cross_Validation.py</span><br><span class="line">_________________________________________</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> KFold</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cross_Validation</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, n_folds</span>):</span><br><span class="line">        self.n_folds = n_folds</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">CV</span>(<span class="params">self,x,y</span>):</span><br><span class="line">        kf = KFold(n_splits=self.n_folds)</span><br><span class="line">        x_train=[]</span><br><span class="line">        x_test=[]</span><br><span class="line">        y_train=[]</span><br><span class="line">        y_test=[]</span><br><span class="line">        <span class="keyword">for</span> train_index,test_index <span class="keyword">in</span> kf.split(x):</span><br><span class="line">            xtr, xte = x[train_index], x[test_index]</span><br><span class="line">            ytr, yte = y[train_index], y[test_index]</span><br><span class="line">            x_train.append(xtr)</span><br><span class="line">            x_test.append(xte)</span><br><span class="line">            y_train.append(ytr)</span><br><span class="line">            y_test.append(yte)</span><br><span class="line">        <span class="keyword">return</span> x_train, x_test, y_train, y_test</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">linearregression.py</span><br><span class="line">_______________________</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">linearregression</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,x,y,Lambda=<span class="number">0</span></span>):</span><br><span class="line">        c = np.dot(x.T, x)</span><br><span class="line">        I = np.eye(np.shape(c)[<span class="number">0</span>])</span><br><span class="line">        d = np.dot(Lambda, I)</span><br><span class="line">        e = (c + d)</span><br><span class="line">        e = np.linalg.inv(e)</span><br><span class="line">        w = np.dot(x.T, y)</span><br><span class="line">        w = np.dot(e, w)</span><br><span class="line">        self.w = w</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,x</span>):</span><br><span class="line">        y=np.dot(x,self.w)</span><br><span class="line">        <span class="keyword">return</span> y</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">Polyfeature.py</span><br><span class="line">____________________</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Polyfeature</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,n_features</span>):</span><br><span class="line">        self.n_features=n_features</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 一元特征混合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self, x</span>):</span><br><span class="line">        <span class="comment"># 单个数字</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(x,<span class="built_in">int</span>):</span><br><span class="line">            x=np.array([x])</span><br><span class="line">        <span class="comment"># 数组计算</span></span><br><span class="line">        xf = np.zeros((<span class="built_in">len</span>(x), self.n_features + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_features + <span class="number">1</span>):</span><br><span class="line">            xf[:,i] = np.power(x, i).reshape(np.shape(xf[:,i]))</span><br><span class="line">        self.xf=xf</span><br><span class="line">        <span class="keyword">return</span> xf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit_transform</span>(<span class="params">self,x</span>):</span><br><span class="line">        <span class="comment"># 单个数字</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(x, <span class="built_in">int</span>):</span><br><span class="line">            x = np.array([x])</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(x,<span class="built_in">float</span>):</span><br><span class="line">            x = np.array([x])</span><br><span class="line">        <span class="comment"># 数组计算</span></span><br><span class="line">        xf = np.zeros((<span class="built_in">len</span>(x), self.n_features + <span class="number">1</span>))</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(self.n_features + <span class="number">1</span>):</span><br><span class="line">            xf[:, i] = np.power(x, i).reshape(np.shape(xf[:, i]))</span><br><span class="line">        <span class="keyword">return</span> xf</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line">PolyRegress.py</span><br><span class="line">______________________________________</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> matplotlib <span class="keyword">as</span> mpl</span><br><span class="line"><span class="keyword">from</span> mpl_toolkits.mplot3d <span class="keyword">import</span> Axes3D</span><br><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line"><span class="keyword">import</span> matplotlib.ticker <span class="keyword">as</span> mticker</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> Polyfeature <span class="keyword">import</span> Polyfeature</span><br><span class="line"><span class="keyword">from</span> linearregression <span class="keyword">import</span> linearregression</span><br><span class="line"><span class="keyword">from</span> Cross_Validation <span class="keyword">import</span> Cross_Validation</span><br><span class="line"><span class="keyword">from</span> createData <span class="keyword">import</span> create_data</span><br><span class="line"><span class="keyword">from</span> createData <span class="keyword">import</span> splitData</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">polyRegression</span>():</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, features, n_lambda</span>):</span><br><span class="line">        self.n_features = features</span><br><span class="line">        self.n_lambda = n_lambda</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 拟合</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fit</span>(<span class="params">self,x,y,l</span>):</span><br><span class="line">        <span class="comment"># 混合特征</span></span><br><span class="line">        pf=Polyfeature(self.n_features)</span><br><span class="line">        pf.fit(x)</span><br><span class="line">        <span class="comment"># 线性回归</span></span><br><span class="line">        lin = linearregression()</span><br><span class="line">        lin.fit(pf.xf,y,Lambda=l)</span><br><span class="line"></span><br><span class="line">        self.lin = lin</span><br><span class="line">        self.poly = pf</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">predict</span>(<span class="params">self,x</span>):</span><br><span class="line">        x=self.poly.fit_transform(x)</span><br><span class="line">        prediction=self.lin.predict(x)</span><br><span class="line">        <span class="keyword">return</span> prediction</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">draw</span>(<span class="params">self,X,t</span>):</span><br><span class="line">        plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line">        plt.figure()</span><br><span class="line">        plt.plot(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>),np.sin(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>)*<span class="number">2</span>*math.pi),c=<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">        plt.scatter(X,t,marker=<span class="string">&#x27;o&#x27;</span>,edgecolor=<span class="string">&#x27;blue&#x27;</span>,c=<span class="string">&#x27;white&#x27;</span>,linewidths=<span class="number">1.1</span>)</span><br><span class="line">        plt.plot(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>),</span><br><span class="line">                 self.lin.predict(self.poly.fit_transform(np.linspace(<span class="number">0</span>,<span class="number">1</span>,<span class="number">50</span>).reshape(-<span class="number">1</span>,<span class="number">1</span>))),</span><br><span class="line">                 c=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        s=<span class="string">&#x27;n_features=&#x27;</span>+<span class="built_in">str</span>(self.n_features)</span><br><span class="line">        plt.text(<span class="number">0.7</span>,<span class="number">1</span>,s)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;X&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;Y&#x27;</span>)</span><br><span class="line">        s=<span class="string">&#x27;cv\\features=&#x27;</span>+<span class="built_in">str</span>(self.n_features)+<span class="string">&#x27; samples=&#x27;</span>+<span class="built_in">str</span>(<span class="number">1</span>)+<span class="string">&#x27;.png&#x27;</span></span><br><span class="line">        plt.savefig(<span class="string">&#x27;11.png&#x27;</span>)</span><br><span class="line">        plt.show()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">cv_pridict</span>(<span class="params">self, X, y, n_fold</span>):</span><br><span class="line">        cv = Cross_Validation(n_fold)</span><br><span class="line">        X_train, X_test, y_train, y_test = cv.CV(X,y)</span><br><span class="line">        y_allPredict = np.ones((<span class="number">1</span>, self.n_lambda))</span><br><span class="line">        Lambda = np.logspace(-<span class="number">10</span>, -<span class="number">7</span>, self.n_lambda)</span><br><span class="line">        w=[]</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(n_fold):</span><br><span class="line">            y_predict = np.zeros((y_test[i].shape[<span class="number">0</span>], self.n_lambda))</span><br><span class="line">            k=<span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> np.nditer(Lambda) :</span><br><span class="line">                <span class="built_in">print</span>(<span class="string">&#x27;第&#x27;</span>,k+<span class="number">1</span>+self.n_lambda*i,<span class="string">&#x27;次:&#x27;</span>,j)</span><br><span class="line">                poly = self.fit(X_train[i], y_train[i], j)</span><br><span class="line">                y_pre = self.predict(X_test[i])</span><br><span class="line">                w.append(self.lin.w)</span><br><span class="line">                y_predict[:, k] = y_pre.ravel()</span><br><span class="line">                k=k+<span class="number">1</span></span><br><span class="line">            y_allPredict = np.vstack((y_allPredict, y_predict))</span><br><span class="line">        y_allPredict = y_allPredict[<span class="number">1</span>:]</span><br><span class="line">        <span class="keyword">return</span> y_allPredict, cv, y_test, y_train, X_test, X_train,w</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">RMSE_CV</span>(<span class="params">self, y_allPredict, y_measure, n</span>):</span><br><span class="line">        press = np.square(np.subtract(y_allPredict, y_measure.reshape(-<span class="number">1</span>,<span class="number">1</span>)))</span><br><span class="line">        press_all = np.<span class="built_in">sum</span>(press, axis=<span class="number">0</span>)</span><br><span class="line">        RMSECV = np.sqrt(press_all / n)</span><br><span class="line">        lambda_best_index= np.argmin(RMSECV)</span><br><span class="line">        lambda_best=np.logspace(-<span class="number">10</span>,-<span class="number">7</span>, self.n_lambda)[lambda_best_index]</span><br><span class="line">        <span class="keyword">return</span> RMSECV, lambda_best</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">bias_cv</span>(<span class="params">self, y_allPredict, y_expect, n</span>):</span><br><span class="line">        press = np.square(np.subtract(y_allPredict, y_expect.reshape(-<span class="number">1</span>,<span class="number">1</span>)))</span><br><span class="line">        press_all = np.<span class="built_in">sum</span>(press, axis=<span class="number">0</span>)</span><br><span class="line">        bias_cv = press_all / n</span><br><span class="line">        <span class="keyword">return</span> bias_cv</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">variance_cv</span>(<span class="params">self,y_allPredict, y_expect</span>):</span><br><span class="line">        press = np.square(np.subtract(y_allPredict, y_expect.reshape(-<span class="number">1</span>,<span class="number">1</span>)))</span><br><span class="line">        variance=np.average(press,axis=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> variance</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">test_error_cv</span>(<span class="params">self,y_allPredict,y,Lambda,w</span>):</span><br><span class="line">        press = np.square(np.subtract(y_allPredict, y.reshape(-<span class="number">1</span>, <span class="number">1</span>)))</span><br><span class="line">        error1 = np.<span class="built_in">sum</span>(press, axis=<span class="number">0</span>)/<span class="number">2</span></span><br><span class="line">        error2 = np.linalg.norm(w,axis=<span class="number">1</span>)</span><br><span class="line">        error_temp=[]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">            e=np.average(error2[i*<span class="number">5</span>:(i+<span class="number">1</span>)*<span class="number">5</span>])</span><br><span class="line">            error_temp.append(e)</span><br><span class="line">        error2=np.array(error_temp)*Lambda/<span class="number">2</span></span><br><span class="line">        error=error1+error2</span><br><span class="line">        <span class="keyword">return</span> error</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">show_Select_lambda</span>(<span class="params">self,RMSECV</span>):</span><br><span class="line">        x=np.logspace(-<span class="number">10</span>,-<span class="number">7</span>,self.n_lambda)</span><br><span class="line">        plt.plot(x,</span><br><span class="line">                 RMSECV,marker=<span class="string">&#x27;^&#x27;</span>,</span><br><span class="line">                 markersize=<span class="number">10</span>,</span><br><span class="line">                 markerfacecolor=<span class="string">&#x27;orange&#x27;</span>,</span><br><span class="line">                 color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">        plt.xlabel(<span class="string">&#x27;lambda&#x27;</span>)</span><br><span class="line">        plt.ylabel(<span class="string">&#x27;RMSECV&#x27;</span>)</span><br><span class="line">        ax = plt.gca()</span><br><span class="line">        ax.set_xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">        ax.set_xlim(ax.get_xlim()[::-<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">RSME</span>(<span class="params">self,X,t</span>):</span><br><span class="line">        T_predict = self.lin.predict(self.poly.fit_transform(X))</span><br><span class="line">        SSE = np.<span class="built_in">sum</span>(np.square(t - T_predict))</span><br><span class="line">        MSE = SSE / <span class="built_in">len</span>(T_predict)</span><br><span class="line">        rsme = np.sqrt(MSE)</span><br><span class="line">        <span class="keyword">return</span> rsme</span><br></pre></td></tr></table></figure><h2 id="调整beta和lambda观察rmse变化">调整<spanclass="math inline">\(\beta\)</span>和<spanclass="math inline">\(\lambda\)</span>观察RMSE变化</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> __name__==<span class="string">&#x27;__name__&#x27;</span>:</span><br><span class="line">   beta=np.linspace(<span class="number">0</span>,<span class="number">0.5</span>,<span class="number">1000</span>)</span><br><span class="line">   Lambda=np.logspace(-<span class="number">10</span>,<span class="number">0</span>,<span class="number">1000</span>)</span><br><span class="line">   RMSE_SUM=[]</span><br><span class="line">   <span class="comment"># beta和lambda对拟合效果影响</span></span><br><span class="line">   <span class="keyword">for</span> j <span class="keyword">in</span> beta:</span><br><span class="line">        poly = polyRegression(<span class="number">8</span>, <span class="number">1000</span>)</span><br><span class="line">        data=create_data(<span class="number">10</span>,j)</span><br><span class="line">        X=data[:,<span class="number">0</span>]</span><br><span class="line">        t=data[:,<span class="number">1</span>]</span><br><span class="line">        y_allPredict, cv, y_test, y_train, X_test, X_train = poly.cv_pridict(X, t, <span class="number">5</span>)</span><br><span class="line">        RMSECV, best_lambda = poly.RMSE_CV(y_allPredict, t, X.shape[<span class="number">0</span>])</span><br><span class="line">        RMSE_SUM.append(RMSECV)</span><br><span class="line">    RMSE=np.array(RMSE_SUM)</span><br><span class="line">    X, Y = np.meshgrid(Lambda, beta)</span><br><span class="line">    fig = plt.figure(figsize=(<span class="number">15</span>,<span class="number">15</span>))</span><br><span class="line">    ax = plt.axes(projection=<span class="string">&#x27;3d&#x27;</span>)</span><br><span class="line">    ax.set_xlabel(<span class="string">&#x27;beta&#x27;</span>)</span><br><span class="line">    ax.set_ylabel(<span class="string">&#x27;lambda&#x27;</span>)</span><br><span class="line">    ax.set_zlabel(<span class="string">&#x27;RSME&#x27;</span>)</span><br><span class="line">    ax.plot_surface(np.log(Y), np.log(X), RMSE, rstride=<span class="number">1</span>, cstride=<span class="number">1</span>, cmap=plt.get_cmap(<span class="string">&#x27;rainbow&#x27;</span>))</span><br><span class="line">    ax.set_title(<span class="string">&#x27;Surface plot&#x27;</span>)</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><center left><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230323215538367.png" alt="image-20230323215538367" style="zoom:50%;"  width="800"/><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230323220045143.png" alt="image-20230323220045143" style="zoom: 33%;" width="1250" /></center><p>右图<span class="math inline">\(-\ln \beta\)</span>值作为x轴，<spanclass="math inline">\(\ln \lambda\)</span>作为y轴，左图反之。</p><p>为了方便观察，对局部作图：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/img.png" alt="img" style="zoom: 67%;" /></p><p>首先，从<span class="math inline">\(\ln\lambda\)</span>方向观察，可以看出<spanclass="math inline">\(\lambda\)</span>对RMSE的影响呈波浪状，存在多个极小值，当<spanclass="math inline">\(\lambda\)</span>取很小的值时，在<spanclass="math inline">\(-ln\beta\)</span>较大的时候出现了比较严重的过拟合。</p><p>然后从<span class="math inline">\(-\ln\beta\)</span>方向观察，可以看出<spanclass="math inline">\(\beta\)</span>对RMSE的影响实际上并不大，呈小而密的波浪趋势。</p><h2 id="正则化前后回归系数">正则化前后回归系数</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 选择参数lambda，给出拟合表达</span></span><br><span class="line">    df=pd.read_csv(<span class="string">&#x27;./data/sample=10.csv&#x27;</span>)</span><br><span class="line">    X=df.values[:,<span class="number">1</span>]</span><br><span class="line">    t=df.values[:,<span class="number">2</span>]</span><br><span class="line">    x_train, x_test, T_train, T_test=splitData(X,t)</span><br><span class="line">    <span class="comment"># 正则化</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        poly = polyRegression(i, <span class="number">50</span>)</span><br><span class="line">        y_allPredict, cv, y_test, y_train, X_test, X_train = poly.cv_pridict(X, t, <span class="number">5</span>)</span><br><span class="line">        RMSECV, best_lambda = poly.RMSE_CV(y_allPredict, t, X.shape[<span class="number">0</span>])</span><br><span class="line">        poly_best=polyRegression(i,<span class="number">5</span>)</span><br><span class="line">        poly_best.fit(x_train,T_train,best_lambda)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;次数为&#x27;</span>,i,<span class="string">&#x27;时的权重集合：&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(poly_best.lin.w)</span><br><span class="line">    <span class="comment"># 无正则化</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;无正则化\n&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">        poly = polyRegression(i, <span class="number">50</span>)</span><br><span class="line">        poly.fit(x_train, T_train, <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;次数为&#x27;</span>, i, <span class="string">&#x27;时的权重集合：&#x27;</span>)</span><br><span class="line">        <span class="built_in">print</span>(poly.lin.w)</span><br><span class="line">    rmse_train=[]</span><br><span class="line">    rmse_test=[]</span><br></pre></td></tr></table></figure><p>无正则化：</p><table><colgroup><col style="width: 6%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 18%" /><col style="width: 6%" /><col style="width: 17%" /></colgroup><thead><tr class="header"><th><span class="math inline">\(w\)</span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>……</th><th>9</th></tr></thead><tbody><tr class="odd"><td></td><td>-0.08673405</td><td>0.43162238</td><td>0.5695881</td><td>-0.05816218</td><td></td><td>-0.07491257</td></tr><tr class="even"><td></td><td></td><td>-1.05343403</td><td>-2.17473669</td><td>11.14510403</td><td></td><td>10.41748047</td></tr><tr class="odd"><td></td><td></td><td></td><td>1.16724815</td><td>-33.31060868</td><td></td><td>-34.4765625</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td>22.29544252</td><td></td><td>56.09375</td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>-60.</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td></td><td>-14.375</td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>34.796875</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td></td><td>44.5625</td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>-2.0625</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td></td><td>-35.390625</td></tr></tbody></table><p>正则化后：</p><table><colgroup><col style="width: 6%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 17%" /><col style="width: 6%" /><col style="width: 17%" /></colgroup><thead><tr class="header"><th><span class="math inline">\(w\)</span></th><th>0</th><th>1</th><th>2</th><th>3</th><th>……</th><th>9</th></tr></thead><tbody><tr class="odd"><td></td><td>-0.07776724</td><td>0.15514244</td><td>0.17544013</td><td>0.33805469</td><td></td><td>0.21515437</td></tr><tr class="even"><td></td><td></td><td>-0.52292037</td><td>-0.38363097</td><td>-0.80726911</td><td></td><td>-0.44372143</td></tr><tr class="odd"><td></td><td></td><td></td><td>-0.25709792</td><td>-0.42717323</td><td></td><td>-0.42050595</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td>0.41092392</td><td></td><td>-0.25649878</td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>-0.10138744</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td></td><td>0.02127489</td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>0.1134249</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td></td><td>0.1815334</td></tr><tr class="odd"><td></td><td></td><td></td><td></td><td></td><td></td><td>0.23170656</td></tr><tr class="even"><td></td><td></td><td></td><td></td><td></td><td></td><td>0.26874031</td></tr></tbody></table><h2 id="bias-variance结构">bias-variance结构</h2><p>程序如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 期望计算</span></span><br><span class="line">    predictAll=[]</span><br><span class="line">    T11=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">100</span>):</span><br><span class="line">        data1 = create_data(<span class="number">25</span>, np.random.uniform(<span class="number">0</span>,<span class="number">0.5</span>))</span><br><span class="line">        X1 = data1[:,<span class="number">0</span>]</span><br><span class="line">        t1 = data1[:,<span class="number">1</span>]</span><br><span class="line">        x1_train, x1_test, T1_train, T1_test = splitData(X1, t1)</span><br><span class="line">        poly_evey=polyRegression(<span class="number">25</span>,<span class="number">100</span>)</span><br><span class="line">        y_allPredict, cv, y_test, y_train, X_test, X_train,w = poly_evey.cv_pridict(X1, t1, <span class="number">5</span>)</span><br><span class="line">        predictAll.append(y_allPredict)</span><br><span class="line">        RMSECV, best_lambda = poly_evey.RMSE_CV(y_allPredict, t1, X1.shape[<span class="number">0</span>])</span><br><span class="line">        poly_evey.fit(x1_train,T1_train,best_lambda)</span><br><span class="line">        t_predict=poly_evey.predict(X1)</span><br><span class="line">        T11.append(t_predict)</span><br><span class="line"></span><br><span class="line">    T1=np.array(T11)</span><br><span class="line">    f_hat=np.average(T1,axis=<span class="number">0</span>)</span><br><span class="line">    poly11=polyRegression(<span class="number">25</span>,<span class="number">100</span>)</span><br><span class="line">    variances=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> predictAll:</span><br><span class="line">        variance=poly11.variance_cv(i,f_hat)</span><br><span class="line">        variances.append(variance)</span><br><span class="line">    variance=np.average(variances,axis=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 生成一个新数据集</span></span><br><span class="line">    data2 = create_data(<span class="number">25</span>, np.random.uniform(<span class="number">0</span>, <span class="number">0.5</span>))</span><br><span class="line">    X2 = data2[:, <span class="number">0</span>]</span><br><span class="line">    t2 = data2[:, <span class="number">1</span>]</span><br><span class="line">    x2_train, x2_test, T2_train, T2_test = splitData(X2, t2)</span><br><span class="line">    poly2=polyRegression(<span class="number">25</span>,<span class="number">100</span>)</span><br><span class="line">    y_allPredict, cv, y_test, y_train, X_test, X_train, w = poly2.cv_pridict(X2, t2, <span class="number">5</span>)</span><br><span class="line">    RMSECV, best_lambda = poly2.RMSE_CV(y_allPredict, t2, X2.shape[<span class="number">0</span>])</span><br><span class="line">    poly2.show_Select_lambda(RMSECV)</span><br><span class="line">    bias_2=poly2.bias_cv(y_allPredict,f_hat,X2.shape[<span class="number">0</span>])</span><br><span class="line">    w=np.array(w)</span><br><span class="line">    error=poly2.test_error_cv(y_allPredict,t2,np.logspace(-<span class="number">10</span>,-<span class="number">7</span>,<span class="number">100</span>),w)</span><br><span class="line">    <span class="built_in">print</span>(bias_2)</span><br><span class="line"></span><br><span class="line">    plt.figure()</span><br><span class="line">    plt.plot(np.logspace(-<span class="number">10</span>,-<span class="number">7</span>, <span class="number">100</span>),bias_2,label=<span class="string">&#x27;bias^2&#x27;</span>,color=<span class="string">&#x27;blue&#x27;</span>)</span><br><span class="line">    plt.plot(np.logspace(-<span class="number">10</span>,-<span class="number">7</span>, <span class="number">100</span>),variance, label=<span class="string">&#x27;variance&#x27;</span>, color=<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">    plt.plot(np.logspace(-<span class="number">10</span>,-<span class="number">7</span>, <span class="number">100</span>),bias_2+variance, label=<span class="string">&#x27;bias^2+variance&#x27;</span>, color=<span class="string">&#x27;pink&#x27;</span>)</span><br><span class="line">    plt.plot(np.logspace(-<span class="number">10</span>,-<span class="number">7</span>, <span class="number">100</span>),error,label=<span class="string">&#x27;test error&#x27;</span>, color=<span class="string">&#x27;black&#x27;</span>)</span><br><span class="line">    ax = plt.gca()</span><br><span class="line">    ax.set_xscale(<span class="string">&quot;log&quot;</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326185731318.png" alt="image-20230326185731318" style="zoom:80%;" /></p><h2 id="degreelambda寻优过程"><spanclass="math inline">\(degree\)</span>、<spanclass="math inline">\(lambda\)</span>寻优过程</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">rmse_train=[]</span><br><span class="line">rmse_test=[]</span><br><span class="line"><span class="comment"># 寻找最优次数</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>):</span><br><span class="line">    poly = polyRegression(i, <span class="number">50</span>)</span><br><span class="line">    poly.fit(x_train,T_train,<span class="number">0</span>)</span><br><span class="line">    rmse_train.append(poly.RSME(x_train,T_train))</span><br><span class="line">    rmse_test.append(poly.RSME(x_test,T_test))</span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>),</span><br><span class="line">         rmse_test,</span><br><span class="line">         label=<span class="string">&#x27;test&#x27;</span>,</span><br><span class="line">         marker=<span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">         markerfacecolor=<span class="string">&#x27;white&#x27;</span></span><br><span class="line">         , markeredgecolor=<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">         color=<span class="string">&#x27;b&#x27;</span>,</span><br><span class="line">         markeredgewidth=<span class="number">1.5</span>)</span><br><span class="line">plt.plot(np.linspace(<span class="number">0</span>,<span class="number">10</span>,<span class="number">10</span>),rmse_train,</span><br><span class="line">         label=<span class="string">&#x27;train&#x27;</span>,</span><br><span class="line">         marker=<span class="string">&#x27;o&#x27;</span>,</span><br><span class="line">         markerfacecolor=<span class="string">&#x27;white&#x27;</span>,</span><br><span class="line">         markeredgecolor=<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">         color=<span class="string">&#x27;r&#x27;</span>,</span><br><span class="line">         markeredgewidth=<span class="number">1.5</span>)</span><br><span class="line">plt.ylabel(<span class="string">&#x27;RMSE&#x27;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;degree&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.legend()</span><br><span class="line">plt.show()</span><br><span class="line">best_degree=np.argmin(np.array(rmse_test))</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;best degree is&#x27;</span>,best_degree)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;min RMSE in test sets:&#x27;</span>,np.<span class="built_in">min</span>(rmse_test))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对最优次数寻找合适的lambda</span></span><br><span class="line">poly = polyRegression(best_degree, <span class="number">50</span>)</span><br><span class="line">poly.fit(x_train, T_train, <span class="number">0</span>)</span><br><span class="line">poly.draw(X,t)</span><br><span class="line">y_allPredict, cv, y_test, y_train, X_test, X_train,w = poly.cv_pridict(X, t, <span class="number">5</span>)</span><br><span class="line">RMSECV, best_lambda = poly.RMSE_CV(y_allPredict, t, X.shape[<span class="number">0</span>])</span><br><span class="line">poly.show_Select_lambda(RMSECV)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;best lambda is&#x27;</span>,best_lambda)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;min RMSE with regularization:&#x27;</span>,np.<span class="built_in">min</span>(RMSECV))</span><br><span class="line">poly_best = polyRegression(best_degree, <span class="number">50</span>)</span><br><span class="line">poly_best.fit(x_train, T_train, best_lambda)</span><br><span class="line">poly_best.draw(X, t)</span><br></pre></td></tr></table></figure><p>degree寻优：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326191813731.png" alt="image-20230326191813731" style="zoom:50%;" /></p><p><span class="math inline">\(lambda\)</span>寻优：</p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326191840244.png" alt="image-20230326191840244" style="zoom: 67%;" /></p>正则化前后图像对比：<center><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326191928367.png" alt="image-20230326191928367" style="zoom:50%;" /><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326191912106.png" alt="image-20230326191912106" style="zoom:50%;" /></center><p>左图为未正则化，右图为正则化后。输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">best degree is 5</span><br><span class="line">min RMSE in test sets: 0.11753272730633338</span><br><span class="line">best lambda is 1.8420699693267162e-08</span><br><span class="line">min RMSE with regularization: 0.0998645060490816</span><br></pre></td></tr></table></figure><h2 id="样本数目影响">样本数目影响</h2><p>代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">RMSEs=[]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>,<span class="number">50</span>):</span><br><span class="line">    data=create_data(i,<span class="number">0.25</span>)</span><br><span class="line">    X=data[:,<span class="number">0</span>]</span><br><span class="line">    t=data[:,<span class="number">1</span>]</span><br><span class="line">    X_train, X_test, T_train, T_test=splitData(X,t)</span><br><span class="line">    poly=polyRegression(<span class="number">8</span>,<span class="number">50</span>)</span><br><span class="line">    poly.fit(X_train,T_train,<span class="number">0</span>)</span><br><span class="line">    rmse=poly.RSME(X,t)</span><br><span class="line">    RMSEs.append(rmse)</span><br><span class="line"></span><br><span class="line">plt.style.use(<span class="string">&#x27;seaborn&#x27;</span>)</span><br><span class="line">plt.figure()</span><br><span class="line">plt.plot(np.linspace(<span class="number">10</span>,<span class="number">50</span>,<span class="number">40</span>),RMSEs)</span><br><span class="line">plt.ylabel(<span class="string">&quot;RMSE&quot;</span>)</span><br><span class="line">plt.xlabel(<span class="string">&#x27;samples&#x27;</span>)</span><br><span class="line">plt.tight_layout()</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326193335597.png" alt="image-20230326193335597" style="zoom:50%;" /></p><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20230326193511771.png" alt="image-20230326193511771" style="zoom:50%;" /></p><p>上图是样本数量在（10,200）的RMSE图，下图是样本数量在（10,20）的RMSE图，可以明显看出随着样布数目增长RMSE逐渐趋于稳定，仅有很小的波动。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python基础语法总结</title>
      <link href="/2022/09/14/pythonSummry/"/>
      <url>/2022/09/14/pythonSummry/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基础语法学习总结"><a href="#Python基础语法学习总结" class="headerlink" title="Python基础语法学习总结"></a>Python基础语法学习总结</h1><h2 id="实验目的"><a href="#实验目的" class="headerlink" title="实验目的"></a>实验目的</h2><p>学习Python基本语法</p><h2 id="实验场地与设备"><a href="#实验场地与设备" class="headerlink" title="实验场地与设备"></a>实验场地与设备</h2><p>线上</p><h2 id="实验方式"><a href="#实验方式" class="headerlink" title="实验方式"></a>实验方式</h2><p>阅读教程与程序设计</p><h2 id="实验设计"><a href="#实验设计" class="headerlink" title="实验设计"></a>实验设计</h2><p> <img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/Python%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80.png" alt="Python语言基础"></p><p>图1.1 Python基础语法学习实验设计</p><h2 id="实验内容"><a href="#实验内容" class="headerlink" title="实验内容"></a>实验内容</h2><h3 id="Python语法总结"><a href="#Python语法总结" class="headerlink" title="Python语法总结"></a>Python语法总结</h3><h4 id="Python基本语法"><a href="#Python基本语法" class="headerlink" title="Python基本语法"></a>Python基本语法</h4><h4 id="基本语句"><a href="#基本语句" class="headerlink" title="基本语句"></a>基本语句</h4><p>①  首先是输入输出语句，输入语句比较简单为<code>name=input()</code>，基本输出语句为<code>print()</code>,拼接输出使用逗号。</p><p>②  注释采用<code>#</code> 进行书写</p><p>③   代码风格：Python采用的是缩进式代码风格，所以对于复制粘贴比较不友好</p><p>④   条件判断语句：<code>if 条件1 :...elif 条件2 : ... else : ...</code></p><p>⑤循环语句：</p><p>第一种是<code>for</code>循环：<code>for x in []:</code> <code>for x in ...:</code> 循环就是把每个元素代入变量x，然后执行缩进块的语句</p><p>第二种是<code>while</code>循环：<code>while 条件判断语句 :</code>    <code>break</code>、<code>continue</code>和java中用法相同</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p><strong>①整数：</strong>对于很大的数，很难数清楚0的个数。Python允许在数字中间以_分隔。</p><p><strong>②浮点数：</strong>允许使用科学计数法定义</p><p><strong>③字符串：</strong>在Python没有严格要求<code>&#39;&#39; </code>和<code>&quot;&quot;</code>的区别在，也就是说没有区分字符和字符串使用二者没有任何区别。</p><ul><li>转义符和Java中保持一致</li><li>Python允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</li></ul><p><strong>④    布尔值：</strong></p><p>在Python中要注意：<code>True</code>、<code>False</code>要注意开头首字母大写。<br>可以进行与、或、非的运算，运算符分别为：<code>and</code>，<code>or</code>，<code>not</code>  </p><p><strong>⑤空值：</strong>空值用<code>None</code>表示，意义与Java中的<code>null</code>相同。</p><p><strong>⑥list：</strong></p><p>list是Python内置的一种数据类型，list是一种有序的集合，可以随时添加和删除其中的元素。此数据类型在Java的实用类中有封装。list和数组很像，声明方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classname = [<span class="string">&#x27;老六&#x27;</span>,<span class="string">&#x27;老八&#x27;</span>,<span class="string">&#x27;老九&#x27;</span>]</span><br></pre></td></tr></table></figure><p>想要调取其中的某个元素也和数组一致，赋值修改等也相同<br>下面列举一下list的ADT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list:</span><br><span class="line">append(&#x27;Elem&#x27;)  # 在末尾添加新的元素</span><br><span class="line">insert(i,&#x27;Elem&#x27;) # 将元素插入指定位置</span><br><span class="line">pop() # 删除末尾元素</span><br><span class="line">pop(i) # 删除i处的元素</span><br><span class="line">len(list) # list列表的长度</span><br></pre></td></tr></table></figure><p>list允许混合类型，也允许list嵌套，从而出现多维数组。</p><p><strong>⑦ tuple</strong></p><p>tuple被称为元组，其最大的特点就是不可修改，声明方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classname = (<span class="string">&#x27;老六&#x27;</span>,<span class="string">&#x27;老八&#x27;</span>,<span class="string">&#x27;老九&#x27;</span>)</span><br></pre></td></tr></table></figure><p>tuple在定义时要确定元素个数，这里有一个问题，在定义只有一个元素的tuple时，Python语法会认为这是一个小括号，因此在定义一个元组的tuple时，要加一个<code>,</code>避免歧义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><p><strong>⑧字典（dict）</strong></p><p>字典全称为dictionary，在Java实用类中叫hash map。其由键值对（key-value）组成，查找速度快。 下面是一种初始化方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure><p>也可以放入指定的key中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="string">&#x27;Adam&#x27;</span>] = <span class="number">67</span></span><br></pre></td></tr></table></figure><p>查找value:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure><p>key与value是多对一的关系，key需要是一个不可变对象保证key做hash运算后的唯一性。如果多次对某个key赋值，后边的value会覆盖前面的value 提供了几个函数：</p><ol><li>通过<code>in</code>来判断key是否在dict中，返回值为布尔值，格式为：<code>key in dict</code></li><li>get()方法，<code>dict.get(&#39;key&#39;,空返回值)</code>key不存在时返回空返回值，空返回值可自定义，如果没有定义的话返回None</li><li>pop()方法，删除key，如果有value也一并删除，格式为<code>pop(&#39;key&#39;)</code></li></ol><p><strong>⑨集合（set）</strong></p><p>set是一组key的集合,集合特点；无序性、确定性、互异性<br>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><ul><li>方法：<br><code>add(key)</code>添加一个新的元素<br><code>remove(key)</code>删除一个元素</li><li>两个set可以做交运算和并运算：<br>交运算：<code>s1&amp;s2</code><br>并运算：<code>s1|s2</code></li></ul><h4 id="理解变量"><a href="#理解变量" class="headerlink" title="理解变量"></a>理解变量</h4><p>在Python中变量仅仅是一个一个字母，变量与所对应的值之间的关系靠指针联系起来的。所以很重要的一点就是：<strong>当我们使用变量时，更多的要关注变量指向的东西，他可能是值，也可能是一个函数，也可能是一个变量</strong></p><h4 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h4><h4 id="模块导入"><a href="#模块导入" class="headerlink" title="模块导入"></a>模块导入</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="模块下载"><a href="#模块下载" class="headerlink" title="模块下载"></a>模块下载</h4><p>模块下载有比较复杂的方法，也有比较傻瓜式的。先说复杂的，使用Python中自带的pip包管理工具，用命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install numpy</span><br></pre></td></tr></table></figure><p>但是使用pip需要事先了解要导的包的名字，而且不能批量导入，而且在Python编程里也有编程一分钟，导包一小时的说法。pip下载第三方库的源可能会很慢或者失效，需要会自己添加国内的高速镜像。</p><p>傻瓜式的导包，例如在pycharm中可以直接在代码中写出自己需要的包，然后交给pycharm自己去下载，或者用Anaconda提前构建好的Python的库环境。</p><h4 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h4><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><p><strong>①函数定义</strong></p><p>在Python中定义函数为，<code>def 函数名(参数):</code>然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。<br>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</p><p>1）空函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这里<code>pass</code>作为占位符，表示跳过，也可以用在<code>if</code>的缩进块。</p><p>2）参数限制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">      <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br></pre></td></tr></table></figure><p>实际上参数限制就是定义一个报错，<code>isinstance()</code>判断数据类型，如果不是就提出一个错误。  <strong>作为一个弱类型语言，定义这一步是很有必要的，有助于读懂代码。</strong></p><p>3）返回值：</p><p>Python允许返回多个值，其返回的实际上是一个tuple元组，但是也可以用两个变量接收。</p><p><strong>②参数定义</strong>  </p><p>在Python中函数参数的定义也比较灵活，提供位置参数、默认参数、可变参数、关键字（key）参数等</p><p>1）位置参数：位置参数指的是参数在传入时，实参和形参有着严格的位置对应关系，为常用参数形式。</p><p>2）默认参数：默认参数是指在位置参数的基础上为其添加默认值，有默认值的参数为默认参数，没有默认值的参数为必选参数<br>基本定义形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_def</span>(<span class="params">a,b=<span class="number">1</span></span>):</span><br><span class="line">    a=b+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>默认参数必须在必选参数后边，否则会无法辨认是否输入必选参数，从而报错。</li><li>默认参数的默认值一定是<strong>不变对象</strong>，由于Python中的变量定义为指针指向，会导致可变对象值发生变化</li></ul><p>3）不可变对象有：数值类型、字符串、tuple元组、None等</p><p>4）可变参数：可变参数指的是参数的数目不固定，定义形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">*v</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> vi <span class="keyword">in</span> v:</span><br><span class="line">        <span class="built_in">sum</span>+=vi</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>在可变参数中传入的所有参数将作为一个tuple被接收，该tuple的变量名为函数在定义时的形参名，定义时的需要在参数名前加一个<code>*</code>。</p><p>5）关键字（key）参数</p><p>此处的关键字和c语言中的关键字并不是一个意义，而是在dict中的key的意义。即在传递参数时，同时传递键（key）和值(value),Python会自动封装为一个dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">**v</span>):</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>6）命名关键字参数</p><p>在关键字参数上，进一步限制传入的key的命名，就有了命名关键词参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br></pre></td></tr></table></figure><p>这里需要一个<code>*</code>区分位置参数与命名关键字参数，如果在这之前有可变参数，那么就不需要加<code>*</code>。<br>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><p>7）参数组合</p><p>在一个函数中使用多个参数要保证其中的顺序，依次为：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onefunction</span>(<span class="params">a,b,c=<span class="number">0</span>,*args,job,city,**kw</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>tips：  </p><ul><li>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法。</li><li>可变参数和关键字参数有一点层级的感觉，中间包裹的是命名关键字参数这个比较尴尬的参数。</li></ul><p><strong>③递归函数</strong></p><p>写法与Java相同。</p><h4 id="实用方法"><a href="#实用方法" class="headerlink" title="实用方法"></a>实用方法</h4><p><strong>①切片</strong></p><p>切片是一个针对tuple和list方便地取元素的方法，语法规则：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L[起始坐标:终止坐标:步长]</span><br></pre></td></tr></table></figure><p>当起始坐标为0时可以省略；步长为1时可以省略。</p><p><strong>②迭代</strong></p><p>迭代是循环的增强，但是想要弄清迭代，需要知道两件事：一个是能不能迭代，一个是迭代出的数据是什么</p><p>想要知道一个数据能否迭代可以通过一个函数来完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">isinstance</span>(L,Iterable)</span><br></pre></td></tr></table></figure><p>迭代出的是什么，和要迭代的对象的储存方式，要特殊记忆一下dic。</p><p><strong>③ 列表生成器</strong></p><p>一种快捷生成list的方式，一个例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><p>如果想要筛选生成的值，可以在<code>for</code>后加上<code>if</code>作为<strong>筛选条件</strong>，注意这里是筛选条件， 因此这里和平时的<code>if else</code>并不是一个东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><p><strong>④ 生成器</strong></p><p>生成器是一种惰性的计算方式。包含<code>yield</code>关键字，当一个函数包含<code>yield</code>关键字时，他就成了一个generator函数。<code>yield</code>在generator函数中起到了一个return的作用，即到<code>yield</code>便返回。 在调用时，使用一个变量接受一个generator对象。使用<code>next()</code>函数依次获得下一个返回值。</p><p><strong>⑤迭代器</strong></p><p>区分<code>Iterable</code>和<code>Iterator</code></p><p><code>Iterable</code>是可迭代的，是直接可用于<code>for</code>循环的。包括dict、list、tuple、set、str、grenerator。<br><code>Iterator</code>是迭代器，是直接可用于<code>next()</code>函数的，生成器都是<code>Iterator</code>对象，集合数据类型可以通过<code>iter()</code>获取<code>Interator</code>对象。</p><h4 id="函数式编程-1"><a href="#函数式编程-1" class="headerlink" title="函数式编程"></a>函数式编程</h4><p>函数式编程是一种面向过程的编程思想，实际上是将复杂问题转化为一个个函数。</p><p>在Java的函数定义中，除去<code>void</code>类型不返回值，其余的都需要返回值。因此也就经常存在，使用一个变量接受函数值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">function</span><span class="params">(x,y)</span>&#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> a=function(x,y);</span><br></pre></td></tr></table></figure><p>那么是不是存在一种可能，我们可以将函数嵌套，让函数调用函数，让函数返回函数，彻底抛弃变量？</p><p>抛弃变量、只有函数就是彻底的函数式编程</p><p><strong>①理解高阶函数</strong></p><p>之前有过变量名和值的理解，在Python中变量名和值是一个指针指向的关系。同理，函数名和函数也是这样的，函数名也是一个变量。也就是说，我们可以通过函数名，拿到函数体。也就是说函数名是什么并不重要，我们看中的是函数体。</p><p>![绘图1](<a href="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/">https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/</a> typora&#x2F;%E7%BB%98%E5%9B%BE1.png)</p><p>那么设想一种情况，现在我们定义了函数f2，那么我可以随便写一个函数，然后返回一个变量f2，那么实际上我就拿到了函数体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f3</span>():</span><br><span class="line">    <span class="keyword">return</span> f2</span><br><span class="line"><span class="built_in">print</span>(f3()(<span class="number">1</span>,<span class="number">2</span>))</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220909173741530.png" alt="image-20220909173741530"></p><p>然后我们在设想另一种情况，现在我们定义了另一种情况，我们在一个函数中写了一个f1作为局部变量，那么我就可以传入变量f2，然后就相当于传入了函数体。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">f2</span>(<span class="params">a,b</span>):</span><br><span class="line">    <span class="keyword">return</span> a+b</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">f1</span>(<span class="params">a,b,f</span>):</span><br><span class="line">    <span class="keyword">return</span> f(a,b)</span><br><span class="line"><span class="built_in">print</span>(f1(<span class="number">1</span>,<span class="number">2</span>,f2))</span><br></pre></td></tr></table></figure><p>现在就可以进行一个区分：</p><ul><li><code>f</code>代表函数名，是变量</li><li><code>f()</code>代表数值，是函数的返回值，返回值是一个量</li></ul><p>高阶函数，就是让函数的参数能够接收别的函数。</p><p>实用的几个函数，有必要查表即可</p><p><strong>②返回函数</strong></p><p>同上文理解，只不过是将一个函数嵌套入了另一个函数</p><p><strong>③ lambda表达式</strong></p><p>与Java中语法相同，目的是为了简化返回函数嵌套</p><h4 id="面向对象编程"><a href="#面向对象编程" class="headerlink" title="面向对象编程"></a>面向对象编程</h4><h4 id="类和对象"><a href="#类和对象" class="headerlink" title="类和对象"></a>类和对象</h4><p>创建类：语法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>(<span class="title class_ inherited__">继承的类</span>):</span><br></pre></td></tr></table></figure><p>python的类非常随意，几乎可以不定义就能用。在类中自带有一个构造函数<code>__init__()</code>,此函数可以重新定义</p><p>生成对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a=A()</span><br></pre></td></tr></table></figure><h4 id="访问权限"><a href="#访问权限" class="headerlink" title="访问权限"></a>访问权限</h4><p>如果要让内部属性不被外部访问，可以把属性的名称前加上两个下划线<code>__</code>，在Python中，实例的变量名如果以<code>__</code>开头，就变成了一个私有变量（private），只有内部可以访问，外部不能访问。</p><p>此外，<code>__ __</code>这种变量都是特殊变量，在不清楚的时候不要随便乱改</p><h4 id="继承和多态"><a href="#继承和多态" class="headerlink" title="继承和多态"></a>继承和多态</h4><p>和Java中的思想完全相同</p><h4 id="常用变量和方法"><a href="#常用变量和方法" class="headerlink" title="常用变量和方法"></a>常用变量和方法</h4><p>①<code>__slots__</code></p><p>用这个变量可以起到参数列表的功能，可以在一定程度上限制参数的变量名，用turple进行限定</p><p>②<code>@property</code></p><p>注解编程，可以起到一个简化定义setter和getter函数的作用。@property注解在getter方法上，然后会自动生成 @函数名.setter 的注解，但是要注意的一点是，在getter中就不能使用函数名作为自身的调用值，否则会出现无限的调用，产生爆栈。</p><p>③多继承</p><p>与Java相同</p><p>⑤<code>__str__</code>:和Java中的toString方法相同</p><h4 id="错误调试"><a href="#错误调试" class="headerlink" title="错误调试"></a>错误调试</h4><h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>参照Java中，对比来学习即可：</p><p>两种方法，一是尝试，二是抛出，尝试采用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> baseexception  :</span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>抛出采用<code>raise</code>关键字</p><h4 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h4><p>①断言：<code>assert</code>的意思是，表达式<code>n != 0</code>应该是<code>True</code>，否则，根据程序运行的逻辑，后面的代码肯定会出错。</p><p>如果断言失败，<code>assert</code>语句本身就会抛出<code>AssertionError</code></p><p>②断点：在强大IDE的辅助下，使用断点调试应该是最简单的。</p><h3 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h3><h4 id="石头剪子布"><a href="#石头剪子布" class="headerlink" title="石头剪子布"></a>石头剪子布</h4><p>使用random包中的random函数和条件控制语句，模拟两个电脑互相猜拳：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">win</span>(<span class="params">pc,cc</span>):</span><br><span class="line">    <span class="keyword">if</span> (cc==<span class="number">1</span> <span class="keyword">and</span> pc==<span class="number">2</span>) <span class="keyword">or</span> (cc==<span class="number">2</span> <span class="keyword">and</span> pc==<span class="number">3</span>)<span class="keyword">or</span>(cc==<span class="number">3</span> <span class="keyword">and</span> pc==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;电脑一输&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> pc==cc:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;平&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;电脑二输&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computer_choice</span>():</span><br><span class="line">    cc=random.randint(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">pc,cc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑一的出招为&quot;</span>,pc)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑二的出招为&quot;</span>,cc)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        pc=computer_choice()</span><br><span class="line">        cc=computer_choice()</span><br><span class="line">        show(pc,cc)</span><br><span class="line">        win(pc,cc)</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914212607801.png" alt="image-20220914212607801"></p><p>改进提升一下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">win</span>(<span class="params">pc,cc</span>):</span><br><span class="line">    <span class="keyword">if</span> (cc==<span class="number">1</span> <span class="keyword">and</span> pc==<span class="number">2</span>) <span class="keyword">or</span> (cc==<span class="number">2</span> <span class="keyword">and</span> pc==<span class="number">3</span>)<span class="keyword">or</span>(cc==<span class="number">3</span> <span class="keyword">and</span> pc==<span class="number">1</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;玩家输&quot;</span>)</span><br><span class="line">    <span class="keyword">elif</span> pc==cc:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;平&quot;</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;玩家赢&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">computer_choice</span>():</span><br><span class="line">    cc=random.randint(<span class="number">1</span>,<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">return</span> cc</span><br><span class="line"><span class="keyword">def</span> <span class="title function_">str</span>(<span class="params">cc</span>):</span><br><span class="line">    <span class="keyword">if</span> cc==<span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;石头&#x27;</span></span><br><span class="line">    <span class="keyword">elif</span> cc==<span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;剪刀&#x27;</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27;布&#x27;</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">show</span>(<span class="params">f,pc,cc</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑一的出招为&quot;</span>,f(pc))</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;电脑二的出招为&quot;</span>,f(cc))</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">        cc=computer_choice()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入：1.石头 2.剪刀 3.布&quot;</span>)</span><br><span class="line">        pc=<span class="built_in">input</span>()</span><br><span class="line">        show(<span class="built_in">str</span>,pc,cc)</span><br><span class="line">        win(pc,cc)</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914213324805.png" alt="image-20220914213324805"></p><h4 id="ATM模拟"><a href="#ATM模拟" class="headerlink" title="ATM模拟"></a>ATM模拟</h4><p>通过类和对象简单的设计了一个ATM取钱模拟器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Account</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ATM</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,money,accounts</span>):</span><br><span class="line">        self.money=money</span><br><span class="line">        self.accounts=accounts</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._money;</span><br><span class="line"><span class="meta">    @money.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">money</span>(<span class="params">self,value</span>):</span><br><span class="line">        self._money=value</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accounts</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self._accounts</span><br><span class="line"><span class="meta">    @accounts.setter</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">accounts</span>(<span class="params">self,value</span>):</span><br><span class="line">        self._accounts=value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">searchId</span>(<span class="params">self,<span class="built_in">id</span></span>):</span><br><span class="line">        <span class="keyword">for</span> account <span class="keyword">in</span> self.accounts:</span><br><span class="line">            <span class="keyword">if</span> account.<span class="built_in">id</span>==<span class="built_in">id</span>:</span><br><span class="line">                <span class="keyword">return</span> account</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">lode</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入账号id&#x27;</span>)</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">input</span>()</span><br><span class="line">        account1 = self.searchId(<span class="built_in">id</span>)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入密码&#x27;</span>)</span><br><span class="line">        password = <span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> password == account1.password:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&quot;欢迎&quot;</span>, account1.name)</span><br><span class="line">        <span class="keyword">return</span> account1</span><br><span class="line">    <span class="comment"># 存钱</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">save_money</span>(<span class="params">self</span>):</span><br><span class="line">        account=self.lode();</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;请输入要存入的数目&quot;</span>)</span><br><span class="line">        saveMneyValue=<span class="built_in">input</span>()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;存款成功&#x27;</span>)</span><br><span class="line">        account.remain=<span class="built_in">int</span>(account.remain)+<span class="built_in">int</span>(saveMneyValue)</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;您的账户余额为&#x27;</span>,account.remain)</span><br><span class="line">        self.money=self.money+<span class="built_in">int</span>(saveMneyValue)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 取钱</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">withdraw_money</span>(<span class="params">self</span>):</span><br><span class="line">        account=self.lode()</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;请输入要取出的数目&#x27;</span>)</span><br><span class="line">        withdrawMoneyValue=<span class="built_in">input</span>()</span><br><span class="line">        <span class="keyword">if</span> account.remain &gt; withdrawMoneyValue:</span><br><span class="line">            account.remain=<span class="built_in">int</span>(account.remain)-<span class="built_in">int</span>(withdrawMoneyValue)</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;取款成功，您的账户余额为&#x27;</span>,account.remain)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="built_in">print</span>(<span class="string">&#x27;您的账户余额不足&#x27;</span>)</span><br><span class="line">        self.money=<span class="built_in">int</span>(self.money)-<span class="built_in">int</span>(withdrawMoneyValue)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;当前ATM中有金额&quot;</span>,self.money,<span class="string">&quot;元&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    <span class="comment"># atm1=ATM(1000)</span></span><br><span class="line">    <span class="comment"># atm1.__str__()</span></span><br><span class="line">    <span class="comment"># atm1.ave_money(200)</span></span><br><span class="line">    <span class="comment"># atm1.__str__()</span></span><br><span class="line">    <span class="comment"># atm1.withdraw_money(200)</span></span><br><span class="line">    <span class="comment"># atm1.__str__()</span></span><br><span class="line">    accounts=[]</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        name=<span class="built_in">input</span>()</span><br><span class="line">        <span class="built_in">id</span> = <span class="built_in">input</span>()</span><br><span class="line">        password=<span class="built_in">input</span>()</span><br><span class="line">        remain=<span class="built_in">input</span>()</span><br><span class="line">        accounts.append(Account.account(name, <span class="built_in">id</span>, password, remain))</span><br><span class="line">    atm2=ATM(<span class="number">10000</span>,accounts)</span><br><span class="line">    atm2.save_money()</span><br><span class="line">    atm2.withdraw_money()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">account</span>(<span class="title class_ inherited__">object</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,name,<span class="built_in">id</span>,password,remain</span>):</span><br><span class="line">        self.name=name</span><br><span class="line">        self.remain=remain</span><br><span class="line">        self.password=password</span><br><span class="line">        self.<span class="built_in">id</span>=<span class="built_in">id</span></span><br><span class="line"></span><br><span class="line">    __slots__ = (<span class="string">&#x27;name&#x27;</span>,<span class="string">&#x27;remain&#x27;</span>,<span class="string">&#x27;password&#x27;</span>,<span class="string">&#x27;id&#x27;</span>)</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914214759256.png" alt="image-20220914214759256"></p><h4 id="圣诞树画图"><a href="#圣诞树画图" class="headerlink" title="圣诞树画图"></a>圣诞树画图</h4><p>使用Python自带的turtle包，进行圣诞树绘制：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> turtle</span><br><span class="line"></span><br><span class="line">screen = turtle.Screen()</span><br><span class="line">screen.setup(<span class="number">375</span>, <span class="number">700</span>)</span><br><span class="line"></span><br><span class="line">circle = turtle.Turtle()</span><br><span class="line">circle.shape(<span class="string">&#x27;circle&#x27;</span>)</span><br><span class="line">circle.color(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">circle.speed(<span class="string">&#x27;fastest&#x27;</span>)</span><br><span class="line">circle.up()</span><br><span class="line"></span><br><span class="line">square = turtle.Turtle()</span><br><span class="line">square.shape(<span class="string">&#x27;square&#x27;</span>)</span><br><span class="line">square.color(<span class="string">&#x27;green&#x27;</span>)</span><br><span class="line">square.speed(<span class="string">&#x27;fastest&#x27;</span>)</span><br><span class="line">square.up()</span><br><span class="line"></span><br><span class="line">circle.goto(<span class="number">0</span>, <span class="number">280</span>)</span><br><span class="line">circle.stamp()</span><br><span class="line"></span><br><span class="line">k = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">13</span>):</span><br><span class="line">    y = <span class="number">30</span> * i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(i - k):</span><br><span class="line">        x = <span class="number">30</span> * j</span><br><span class="line">        square.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line">        square.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">0</span>:</span><br><span class="line">        x = <span class="number">30</span> * (j + <span class="number">1</span>)</span><br><span class="line">        circle.color(<span class="string">&#x27;red&#x27;</span>)</span><br><span class="line">        circle.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line">        circle.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line">        k += <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">4</span> == <span class="number">3</span>:</span><br><span class="line">        x = <span class="number">30</span> * (j + <span class="number">1</span>)</span><br><span class="line">        circle.color(<span class="string">&#x27;yellow&#x27;</span>)</span><br><span class="line">        circle.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line">        circle.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        circle.stamp()</span><br><span class="line"></span><br><span class="line">square.color(<span class="string">&#x27;brown&#x27;</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">13</span>, <span class="number">17</span>):</span><br><span class="line">    y = <span class="number">30</span> * i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>):</span><br><span class="line">        x = <span class="number">30</span> * j</span><br><span class="line">        square.goto(x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line">        square.goto(-x, -y + <span class="number">280</span>)</span><br><span class="line">        square.stamp()</span><br><span class="line">turtle.mainloop()</span><br></pre></td></tr></table></figure><p><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/image-20220914215352995.png" alt="image-20220914215352995"></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Python作为一个弱类型语言，是有他的弊端的，在一些需要数据类型转换和严格控制数据类型的情况下，会非常难受。而Python最大的优势在于有大量的库，这些库在特定的编程领域会非常便利。Python本身的语言具有极强的灵活性，而灵活性的言外之意就是规范性很难确定。因此，Python的重点是将第三方包为我所用，在数值计算中发挥他最大的作用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期Python学习（四）</title>
      <link href="/2022/07/18/day-4/"/>
      <url>/2022/07/18/day-4/</url>
      
        <content type="html"><![CDATA[<h1 id="函数高级特性"><a href="#函数高级特性" class="headerlink" title="函数高级特性"></a>函数高级特性</h1><h2 id="切片（Slice）"><a href="#切片（Slice）" class="headerlink" title="切片（Slice）"></a>切片（Slice）</h2><p>切片是一个针对tuple和list方便地取元素的方法，下面举例说明：</p><ol><li>取出list L中的0到3个元素</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L[<span class="number">0</span>:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>当取出元素从第0个开始时，第一个数字可以缺省</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L[:<span class="number">3</span>]</span><br></pre></td></tr></table></figure><ol><li>取出倒数后三个元素<br>在Python中允许使用<code>L[-1]</code>来取出倒数第一个数，因此可以这样倒着取：</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L[-<span class="number">3</span>:]</span><br></pre></td></tr></table></figure><ol><li>每两个数取一个数<br>切片的最后一个数字表示步长，步长为多少就隔几个数字。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">L[:<span class="number">10</span>:<span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>字符串和tuple同样可以这样使用，只不过返回值为对应类型。</p><h2 id="迭代（Iteration）"><a href="#迭代（Iteration）" class="headerlink" title="迭代（Iteration）"></a>迭代（Iteration）</h2><p>Python的迭代相比c或者Java来说，功能更强大，除了可以迭代list，还可以迭代dict这种无下标的数据类型。<br>想要知道一个数据能否迭代可以通过一个函数来完成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line">L=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"><span class="built_in">isinstance</span>(L,Iterable)</span><br></pre></td></tr></table></figure><p>下面说明dict如何迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">d=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">1</span>,<span class="string">&#x27;b&#x27;</span>:<span class="number">2</span>,<span class="string">&#x27;c&#x27;</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 迭代key</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> d:</span><br><span class="line">    <span class="built_in">print</span>(key)</span><br><span class="line"><span class="comment"># 迭代value</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> d.values():</span><br><span class="line">    <span class="built_in">print</span>(value)</span><br><span class="line"><span class="comment"># 迭代key和value</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> d.items:</span><br><span class="line">    <span class="built_in">print</span>(k)</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br></pre></td></tr></table></figure><p>需要理解的是，这里的key，value，k，v都是for循环中的形参，没有实际意义。也就是说当<code>in d</code>的时候默认就是取<code>key</code> 。当要迭代其他的时候只需要更改<code>in</code>的后面。我猜测这可能与dict的存储方式有关。</p><p>多个元素同时迭代在其他list中也是可以实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">l=&#123;(<span class="number">1</span>,<span class="number">2</span>),(<span class="number">3</span>,<span class="number">4</span>),(<span class="number">5</span>,<span class="number">6</span>)&#125;</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> l:</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line"><span class="keyword">for</span> x,y <span class="keyword">in</span> l:</span><br><span class="line">    <span class="built_in">print</span>(x,y)</span><br></pre></td></tr></table></figure><h2 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式"></a>列表生成式</h2><p>一种快捷生成list的方式，一个例子如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>)]</span><br></pre></td></tr></table></figure><p>如果想要筛选生成的值，可以在<code>for</code>后加上<code>if</code>作为<strong>筛选条件</strong>，注意这里是筛选条件， 因此这里和平时的<code>if else</code>并不是一个东西。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">11</span>) <span class="keyword">if</span> x % <span class="number">2</span> == <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。</p><h3 id="创建generator"><a href="#创建generator" class="headerlink" title="创建generator"></a>创建generator</h3><ol><li>把一个列表生成式的<code>[]</code>改成<code>(）</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br></pre></td></tr></table></figure><ol><li>包含<code>yield</code>关键字<br>当一个函数包含<code>yield</code>关键字时，他就成了一个generator函数。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">fib</span>(<span class="params"><span class="built_in">max</span></span>):</span><br><span class="line">    n, a, b = <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;done&#x27;</span></span><br></pre></td></tr></table></figure><p><code>yield</code>在generator函数中起到了一个return的作用，即到<code>yield</code>便返回。 在调用时，使用一个变量接受一个generator对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f = fib(<span class="number">6</span>)</span><br></pre></td></tr></table></figure><h3 id="调用generator获得值"><a href="#调用generator获得值" class="headerlink" title="调用generator获得值"></a>调用generator获得值</h3><ol><li>使用<code>next()</code>函数依次获得下一个返回值</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">next</span>(f)</span><br></pre></td></tr></table></figure><ol><li>使用<code>for</code>循环</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">g = (x * x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>))</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> g:</span><br><span class="line">    <span class="built_in">print</span>(n)</span><br></pre></td></tr></table></figure><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="区分Iterable和Iterator"><a href="#区分Iterable和Iterator" class="headerlink" title="区分Iterable和Iterator"></a>区分<code>Iterable</code>和<code>Iterator</code></h3><p><code>Iterable</code>是可迭代的，是直接可用于<code>for</code>循环的。包括dict、list、tuple、set、str、grenerator。<br><code>Iterator</code>是迭代器，是直接可用于<code>next()</code>函数的，生成器都是<code>Iterator</code>对象，集合数据类型可以通过<code>iter()</code>获取<code>Interator</code>对象。</p><h3 id="for循环的本质"><a href="#for循环的本质" class="headerlink" title="for循环的本质"></a><code>for</code>循环的本质</h3><p>在Python中<code>for</code>循环本质上就是一个不断调用<code>next()</code>的过程。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">it=<span class="built_in">iter</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        x=<span class="built_in">next</span>(it)</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        <span class="keyword">break</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期Python学习（三）</title>
      <link href="/2022/07/16/day3/"/>
      <url>/2022/07/16/day3/</url>
      
        <content type="html"><![CDATA[<h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>在Python中定义函数为，<code>def 函数名(参数):</code>然后，在缩进块中编写函数体，函数的返回值用<code>return</code>语句返回。<br>如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。</p><h3 id="空函数"><a href="#空函数" class="headerlink" title="空函数"></a>空函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">nop</span>():</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在这里<code>pass</code>作为占位符，表示跳过，也可以用在<code>if</code>的缩进块。</p><h3 id="参数限制"><a href="#参数限制" class="headerlink" title="参数限制"></a>参数限制</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(x, (<span class="built_in">int</span>, <span class="built_in">float</span>)):</span><br><span class="line">      <span class="keyword">raise</span> TypeError(<span class="string">&#x27;bad operand type&#x27;</span>)</span><br></pre></td></tr></table></figure><p>实际上参数限制就是定义一个报错，<code>isinstance()</code>判断数据类型，如果不是就提出一个错误。<br><strong><strong>作为一个弱类型语言，定义这一步是很有必要的，有助于读懂代码。</strong></strong></p><h3 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h3><p>Python允许返回多个值，其返回的实际上是一个tuple元组，但是也可以用两个变量接收。</p><h3 id="参数定义"><a href="#参数定义" class="headerlink" title="参数定义"></a>参数定义</h3><p>在Python中函数参数的定义也比较灵活，提供位置参数、默认参数、可变参数、关键字（key）参数等</p><h4 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h4><p>位置参数指的是参数在传入时，实参和形参有着严格的位置对应关系，为常用参数形式。</p><h4 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h4><p>默认参数是指在位置参数的基础上为其添加默认值，有默认值的参数为默认参数，没有默认值的参数为必选参数<br>基本定义形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_def</span>(<span class="params">a,b=<span class="number">1</span></span>):</span><br><span class="line">    a=b+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><p>需要注意的是：</p><ul><li>默认参数必须在必选参数后边，否则会无法辨认是否输入必选参数，从而报错。</li><li>默认参数的默认值一定是<strong>不变对象</strong>，由于Python中的变量定义为指针指向，会导致可变对象值发生变化</li></ul><p>不可变对象有：数值类型、字符串、tuple元组、None等</p><h4 id="可变参数"><a href="#可变参数" class="headerlink" title="可变参数"></a>可变参数</h4><p>可变参数指的是参数的数目不固定，定义形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">*v</span>):</span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> vi <span class="keyword">in</span> v:</span><br><span class="line">        <span class="built_in">sum</span>+=vi</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure><p>在可变参数中传入的所有参数将作为一个tuple被接收，该tuple的变量名为函数在定义时的形参名，<br>定义时的需要在参数名前加一个<code>*</code>。</p><h4 id="关键字（key）参数"><a href="#关键字（key）参数" class="headerlink" title="关键字（key）参数"></a>关键字（key）参数</h4><p>此处的关键字和c语言中的关键字并不是一个意义，而是在dict中的key的意义。即在传递参数时<br>，同时传递键（key）和值(value),Python会自动封装为一个dict。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>(<span class="params">**v</span>):</span><br><span class="line">    <span class="built_in">print</span>(v)</span><br><span class="line">    <span class="keyword">return</span> </span><br></pre></td></tr></table></figure><h4 id="命名关键字参数"><a href="#命名关键字参数" class="headerlink" title="命名关键字参数"></a>命名关键字参数</h4><p>在关键字参数上，进一步限制传入的key的命名，就有了命名关键词参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">person</span>(<span class="params">name, age, *, city, job</span>):</span><br><span class="line">    <span class="built_in">print</span>(name, age, city, job)</span><br></pre></td></tr></table></figure><p>这里需要一个<code>*</code>区分位置参数与命名关键字参数，如果在这之前有可变参数，那么就不需要加<code>*</code>。<br>命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&#x27;Jack&#x27;</span>, <span class="number">24</span>, <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;Engineer&#x27;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: person() missing <span class="number">2</span> required keyword-only arguments: <span class="string">&#x27;city&#x27;</span> <span class="keyword">and</span> <span class="string">&#x27;job&#x27;</span></span><br></pre></td></tr></table></figure><h4 id="参数组合"><a href="#参数组合" class="headerlink" title="参数组合"></a>参数组合</h4><p>在一个函数中使用多个参数要保证其中的顺序，依次为：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。  </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">onefunction</span>(<span class="params">a,b,c=<span class="number">0</span>,*args,job,city,**kw</span>):</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>tips：  </p><ul><li>使用<code>*args</code>和<code>**kw</code>是Python的习惯写法。</li><li>可变参数和关键字参数有一点层级的感觉，中间包裹的是命名关键字参数这个比较尴尬的参数。</li></ul><h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>写法与Java相同。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Python学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期Python学习（二）</title>
      <link href="/2022/07/10/day2/"/>
      <url>/2022/07/10/day2/</url>
      
        <content type="html"><![CDATA[<h1 id="Python基本语法"><a href="#Python基本语法" class="headerlink" title="Python基本语法"></a>Python基本语法</h1><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>首先必须说明一点，Python和JavaScript一样是一个弱类型语言，和Java、C++有所不同<br>，Python在定义变量时，无需进行类型声明。</p><h3 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h3><p>对于很大的数，很难数清楚0的个数。Python允许在数字中间以_分隔。</p><h3 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h3><p>允许使用科学计数法定义</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>在Python没有严格要求<code>&#39;&#39; </code>和<code>&quot;&quot;</code>的区别在，也就是说没有区分字符和字符串<br>使用二者没有任何区别。</p><ul><li>转义符和Java中保持一致</li><li>Python允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">r&#x27;\t\\&#x27;</span>)</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\t\\</span><br></pre></td></tr></table></figure><ul><li>Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，输出结果按行。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;&#x27;这是一个</span></span><br><span class="line"><span class="string">很长很长</span></span><br><span class="line"><span class="string">的句子&#x27;&#x27;&#x27;</span>)</span><br></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>在Python中要注意：<code>True</code>、<code>False</code>要注意开头首字母大写。<br>可以进行与、或、非的运算，运算符分别为：<code>and</code>，<code>or</code>，<code>not</code>  </p><h3 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h3><p>空值用<code>None</code>表示，意义与Java中的<code>null</code>相同。</p><h2 id="变量与常量"><a href="#变量与常量" class="headerlink" title="变量与常量"></a>变量与常量</h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>变量名必须是大小写英文、数字和<code>_</code>的组合，且不能用数字开头</p><ul><li>在变量创立时，Python是这样的：<br>① 找一块内存，存储一个数值<br>② 找一块内存，建立一个变量，将这个变量指向数值</li><li>这里注意Python的变量建立和指针相关。</li></ul><h3 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h3><p>在Python中，通常用全部大写的变量名表示常量，但是并不能保证常量不变</p><h2 id="list和tuple"><a href="#list和tuple" class="headerlink" title="list和tuple"></a>list和tuple</h2><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是Python内置的一种数据类型，list是一种有序的集合，可以随时添加和删除其中的元素。<br>此数据类型在Java的实用类中有封装。<br>list和数组很像，声明方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classname = [<span class="string">&#x27;老六&#x27;</span>,<span class="string">&#x27;老八&#x27;</span>,<span class="string">&#x27;老壁灯&#x27;</span>]</span><br></pre></td></tr></table></figure><p>想要调取其中的某个元素也和数组一致，赋值修改等也相同<br>下面列举一下list的ADT</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list:</span><br><span class="line">append(&#x27;Elem&#x27;)  # 在末尾添加新的元素</span><br><span class="line">insert(i,&#x27;Elem&#x27;) # 将元素插入指定位置</span><br><span class="line">pop() # 删除末尾元素</span><br><span class="line">pop(i) # 删除i处的元素</span><br><span class="line">len(list) # list列表的长度</span><br></pre></td></tr></table></figure><p>list允许混合类型，也允许list嵌套，从而出现多维数组。</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>tuple被称为元组，其最大的特点就是不可修改，声明方式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classname = (<span class="string">&#x27;老六&#x27;</span>,<span class="string">&#x27;老八&#x27;</span>,<span class="string">&#x27;老壁灯&#x27;</span>)</span><br></pre></td></tr></table></figure><p>tuple在定义时要确定元素个数，这里有一个问题，在定义只有一个元素的tuple时，Python<br>语法会认为这是一个小括号，因此在定义一个元组的tuple时，要加一个<code>,</code>避免歧义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t=(<span class="number">1</span>,)</span><br></pre></td></tr></table></figure><h2 id="流程控制语句"><a href="#流程控制语句" class="headerlink" title="流程控制语句"></a>流程控制语句</h2><h3 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h3><p>if语句，需要注意的是Python中的流程控制语句结尾都是冒号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="built_in">input</span>()</span><br><span class="line">a=<span class="built_in">int</span>(a)</span><br><span class="line"><span class="keyword">if</span> a&lt;<span class="number">1</span>:</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">elif</span> a&gt;<span class="number">2</span>:</span><br><span class="line">    <span class="built_in">print</span>()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="built_in">print</span>()</span><br></pre></td></tr></table></figure><p>因为是弱类型语言，在比较、计算时要给数据指定一个类型。</p><h3 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h3><ul><li><code>for x in []:</code><br><code>for x in ...:</code>循环就是把每个元素代入变量x，然后执行缩进块的语句<br>tips：</li></ul><ol><li>in后边可以是list或者tuple，也可以跟range(x)</li><li>Python提供了range(x)函数，生成[0,x-1]的整数</li></ol><ul><li><p><code>while</code><br><code>while 条件判断语句 :</code></p></li><li><p><code>break</code>、<code>continue</code>和java中用法相同</p></li></ul><h2 id="字典（dict）与集合（set）"><a href="#字典（dict）与集合（set）" class="headerlink" title="字典（dict）与集合（set）"></a>字典（dict）与集合（set）</h2><h3 id="字典（dict）"><a href="#字典（dict）" class="headerlink" title="字典（dict）"></a>字典（dict）</h3><p>字典全称为dictionary，在Java实用类中叫hash map。其由键值对（key-value）组成，查找速度快。 下面是一种初始化方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = &#123;<span class="string">&#x27;Michael&#x27;</span>: <span class="number">95</span>, <span class="string">&#x27;Bob&#x27;</span>: <span class="number">75</span>, <span class="string">&#x27;Tracy&#x27;</span>: <span class="number">85</span>&#125;</span><br></pre></td></tr></table></figure><p>也可以放入指定的key中：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="string">&#x27;Adam&#x27;</span>] = <span class="number">67</span></span><br></pre></td></tr></table></figure><p>查找value:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d[<span class="string">&#x27;Adam&#x27;</span>]</span><br></pre></td></tr></table></figure><p>key与value是多对一的关系，key需要是一个不可变对象保证key做hash运算后的唯一性。如果多次对某个key赋值，后边的value会覆盖前面的value 提供了几个函数：</p><ol><li>通过<code>in</code>来判断key是否在dict中，返回值为布尔值，格式为：<code>key in dict</code></li><li>get()方法，<code>dict.get(&#39;key&#39;,空返回值)</code>key不存在时返回空返回值，空返回值可自定义，如果没有定义的话返回None</li><li>pop()方法，删除key，如果有value也一并删除，格式为<code>pop(&#39;key&#39;)</code></li></ol><h3 id="集合（set）"><a href="#集合（set）" class="headerlink" title="集合（set）"></a>集合（set）</h3><p>set是一组key的集合,集合特点；无序性、确定性、互异性<br>要创建一个set，需要提供一个list作为输入集合：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="built_in">set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><ul><li>方法：<br><code>add(key)</code>添加一个新的元素<br><code>remove(key)</code>删除一个元素</li><li>两个set可以做交运算和并运算：<br>交运算：<code>s1&amp;s2</code><br>并运算：<code>s1|s2</code></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Python学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>暑期Python学习（一）</title>
      <link href="/2022/07/10/day_1/"/>
      <url>/2022/07/10/day_1/</url>
      
        <content type="html"><![CDATA[<h1 id="Python入门"><a href="#Python入门" class="headerlink" title="Python入门"></a>Python入门</h1><p> 个人笔记，在有C++和Java基础下的学习。</p><h2 id="命令控制行和python交互页面的区别："><a href="#命令控制行和python交互页面的区别：" class="headerlink" title="命令控制行和python交互页面的区别："></a>命令控制行和python交互页面的区别：</h2><ul><li>命令控制行：输入命令Python进入交互界面，然后可以写Python命令，<br>可以通过<code>python 文件名.py</code>运行整个Python文件。使用<code>exit（） </code>命令退出。<br><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/day_1_2.png" alt="day_1_2"></li><li>Python交互界面：直接输入Python语句，不能运行整个Python文件。<br><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/day_1_1.png" alt="day_1_1"><br>Python交互模式主要是为了调试Python代码用的，也便于初学者学习，它不是正式运行Python代码的环境！<br>tip：SyntaxError指的是代码语法有错误。</li></ul><h2 id="第一个程序"><a href="#第一个程序" class="headerlink" title="第一个程序"></a>第一个程序</h2><p>写一个hello world，用记事本或者IDE都可以。通过命令控制行运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&quot;hello world&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>在py文件所在目录下，打开命令控制行，使用命令运行：<br><img src="https://blogpicture-1310464487.cos.ap-nanjing.myqcloud.com/%20typora/day_1_3.png" alt="day_1_3"></li></ul><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>输入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">input</span>(<span class="string">&#x27;这里可以加一个提示，不必用print&#x27;</span>)     <span class="comment"># name是接收变量</span></span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;&#x27;</span>,<span class="string">&#x27;&#x27;</span>)  <span class="comment"># 用于连续输出，中间有空格</span></span><br></pre></td></tr></table></figure><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用#表示注释</span></span><br></pre></td></tr></table></figure><h2 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h2><p>Python中代码采用缩进，可以不写分号。<code>:</code>结尾时，后续视为代码块自动缩进（采用IDE时），缩进距离无限制<br>一般为四个空格。显然Python对cv工程师很不友好，要检查缩进是否正确。<br>Python是大小写敏感型。 </p>]]></content>
      
      
      
        <tags>
            
            <tag> Python学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/01/hello-world/"/>
      <url>/2022/07/01/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p><p><a href="https://zh.usa1lib.org/booklist/155353/c2a989">书集 (usa1lib.org)</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
